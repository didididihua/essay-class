/*
SQLyog Community v13.1.7 (64 bit)
MySQL - 8.0.25 : Database - diso_db
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`diso_db` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `diso_db`;

/*Table structure for table `label` */

DROP TABLE IF EXISTS `label`;

CREATE TABLE `label` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `parentId` bigint NOT NULL COMMENT '父类id',
  `labelName` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名称',
  `createTime` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updateTime` timestamp NULL DEFAULT NULL COMMENT '修改时间',
  `isDelete` tinyint DEFAULT NULL COMMENT '逻辑删除标志',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=318 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `label` */

insert  into `label`(`id`,`parentId`,`labelName`,`createTime`,`updateTime`,`isDelete`) values 
(1,0,'测试',NULL,NULL,NULL),
(2,0,'测试2',NULL,NULL,NULL),
(9,0,'用户','2023-05-05 15:40:29','2023-05-05 15:40:29',0),
(10,9,'方向','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(11,10,'前端','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(12,10,'后端','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(13,10,'人工智能','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(14,10,'数据分析','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(15,10,'图像处理','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(16,10,'信息安全','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(17,10,'计算机视觉','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(18,10,'爬虫','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(19,10,'NLP','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(20,10,'项目管理','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(21,10,'嵌入式','2023-05-05 15:40:44','2023-05-05 15:40:44',0),
(22,10,'物联网','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(23,10,'数据库','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(24,10,'大数据','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(25,10,'游戏开发','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(26,10,'音视频','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(27,10,'产品','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(28,10,'设计','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(29,10,'运营','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(30,10,'测试','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(31,10,'区块链','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(32,10,'安全','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(33,10,'移动开发','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(34,10,'小程序','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(35,10,'云计算','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(36,10,'云原生','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(37,10,'运维','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(38,10,'网络工程','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(39,9,'目标','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(40,39,'实习','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(41,39,'校招','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(42,39,'社招','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(43,39,'竞赛','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(44,39,'读研','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(45,39,'读博','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(46,39,'考证','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(47,39,'留学','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(48,39,'考公','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(49,9,'学历','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(50,49,'专科','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(51,49,'本科','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(52,49,'一本','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(53,49,'211本','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(54,49,'985本','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(55,49,'硕士','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(56,49,'211硕','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(57,49,'985硕','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(58,49,'海外本','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(59,49,'海外硕','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(60,49,'博士','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(61,9,'工作状态','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(62,61,'在校','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(63,61,'求职中','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(64,61,'实习中','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(65,61,'已工作','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(66,9,'岗位','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(67,66,'前端','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(68,66,'后端','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(69,66,'客户端','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(70,66,'算法','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(71,66,'嵌入式','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(72,66,'物联网','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(73,66,'测试','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(74,66,'运维','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(75,66,'爬虫','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(76,66,'大数据','2023-05-05 15:40:45','2023-05-05 15:40:45',0),
(77,66,'产品','2023-05-05 15:40:46','2023-05-05 15:40:46',0),
(78,66,'运营','2023-05-05 15:40:46','2023-05-05 15:40:46',0),
(79,66,'数据分析','2023-05-05 15:40:46','2023-05-05 15:40:46',0),
(80,66,'游戏开发','2023-05-05 15:40:46','2023-05-05 15:40:46',0),
(81,0,'问答','2023-05-05 15:40:51','2023-05-05 15:40:51',0),
(82,81,'类别','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(83,82,'学习建议','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(84,82,'技术交流','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(85,82,'Bug','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(86,82,'求职','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(87,82,'面试','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(88,82,'职场','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(89,82,'生活','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(90,81,'编程语言','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(91,90,'Java','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(92,90,'C#','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(93,90,'PHP','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(94,90,'C++','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(95,90,'C语言','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(96,90,'HTML','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(97,90,'CSS','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(98,90,'Javascript','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(99,90,'Go','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(100,90,'Python','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(101,90,'Rust','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(102,90,'Ruby','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(103,90,'Swift','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(104,90,'Scala','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(105,90,'Lua','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(106,90,'Bash','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(107,90,'Kotlin','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(108,81,'知识','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(109,108,'数据结构','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(110,108,'算法','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(111,108,'软件工程','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(112,108,'数据库','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(113,108,'操作系统','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(114,108,'Linux','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(115,108,'设计模式','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(116,108,'分布式','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(117,108,'计算机网络','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(118,108,'系统设计','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(119,108,'编译原理','2023-05-05 15:40:55','2023-05-05 15:40:55',0),
(120,0,'直播','2023-05-05 15:41:00','2023-05-05 15:41:00',0),
(121,120,'推荐','2023-05-05 15:41:09','2023-05-05 15:41:09',0),
(122,121,'项目','2023-05-05 15:41:09','2023-05-05 15:41:09',0),
(123,121,'经验分享','2023-05-05 15:41:09','2023-05-05 15:41:09',0),
(124,121,'交流答疑','2023-05-05 15:41:09','2023-05-05 15:41:09',0),
(125,0,'简历','2023-05-05 15:41:16','2023-05-05 15:41:16',0),
(126,125,'招聘类别','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(127,126,'实习','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(128,126,'校招','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(129,126,'社招','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(130,125,'岗位','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(131,130,'前端','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(132,130,'后端','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(133,130,'客户端','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(134,130,'算法','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(135,130,'嵌入式','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(136,130,'物联网','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(137,130,'测试','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(138,130,'运维','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(139,130,'爬虫','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(140,130,'大数据','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(141,130,'产品','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(142,130,'运营','2023-05-05 15:41:19','2023-05-05 15:41:19',0),
(143,130,'数据分析','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(144,130,'游戏开发','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(145,125,'方向','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(146,145,'前端','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(147,145,'后端','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(148,145,'人工智能','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(149,145,'数据分析','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(150,145,'图像处理','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(151,145,'信息安全','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(152,145,'计算机视觉','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(153,145,'爬虫','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(154,145,'NLP','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(155,145,'项目管理','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(156,145,'嵌入式','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(157,145,'物联网','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(158,145,'数据库','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(159,145,'大数据','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(160,145,'游戏开发','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(161,145,'音视频','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(162,145,'产品','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(163,145,'设计','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(164,145,'运营','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(165,145,'测试','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(166,145,'区块链','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(167,145,'安全','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(168,145,'移动开发','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(169,145,'小程序','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(170,145,'云计算','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(171,145,'云原生','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(172,145,'运维','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(173,145,'网络工程','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(174,125,'学历','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(175,174,'专科','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(176,174,'本科','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(177,174,'一本','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(178,174,'211本','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(179,174,'985本','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(180,174,'硕士','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(181,174,'211硕','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(182,174,'985硕','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(183,174,'海外本','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(184,174,'海外硕','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(185,174,'博士','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(186,125,'年级','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(187,186,'大一','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(188,186,'大二','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(189,186,'大三','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(190,186,'大四','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(191,186,'研一','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(192,186,'研二','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(193,186,'研三','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(194,125,'工作经验','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(195,194,'一年','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(196,194,'三年','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(197,194,'五年','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(198,194,'五年以上','2023-05-05 15:41:20','2023-05-05 15:41:20',0),
(199,0,'面试题','2023-05-05 15:41:51','2023-05-05 15:41:51',0),
(200,199,'推荐','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(201,200,'面试题挑战','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(202,200,'Java','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(203,200,'前端','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(204,200,'Python','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(205,200,'测试','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(206,200,'算法','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(207,200,'人工智能','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(208,200,'Go','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(209,200,'C++','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(210,200,'运维','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(211,200,'大数据','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(212,199,'类别','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(213,212,'学习建议','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(214,212,'技术交流','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(215,212,'Bug','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(216,212,'求职','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(217,212,'面试','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(218,212,'职场','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(219,212,'生活','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(220,199,'编程语言','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(221,220,'Java','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(222,220,'C#','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(223,220,'PHP','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(224,220,'C++','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(225,220,'C语言','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(226,220,'HTML','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(227,220,'CSS','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(228,220,'Javascript','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(229,220,'Go','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(230,220,'Python','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(231,220,'Rust','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(232,220,'Ruby','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(233,220,'Swift','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(234,220,'Scala','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(235,220,'Lua','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(236,220,'Bash','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(237,220,'Kotlin','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(238,199,'方向','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(239,238,'前端','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(240,238,'后端','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(241,238,'人工智能','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(242,238,'数据分析','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(243,238,'图像处理','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(244,238,'信息安全','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(245,238,'计算机视觉','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(246,238,'爬虫','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(247,238,'NLP','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(248,238,'项目管理','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(249,238,'嵌入式','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(250,238,'物联网','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(251,238,'数据库','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(252,238,'大数据','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(253,238,'游戏开发','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(254,238,'音视频','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(255,238,'产品','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(256,238,'设计','2023-05-05 15:41:54','2023-05-05 15:41:54',0),
(257,238,'运营','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(258,238,'测试','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(259,238,'区块链','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(260,238,'安全','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(261,238,'移动开发','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(262,238,'小程序','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(263,238,'云计算','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(264,238,'云原生','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(265,238,'运维','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(266,238,'网络工程','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(267,199,'知识','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(268,267,'数据结构','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(269,267,'算法','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(270,267,'软件工程','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(271,267,'数据库','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(272,267,'操作系统','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(273,267,'Linux','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(274,267,'设计模式','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(275,267,'分布式','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(276,267,'计算机网络','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(277,267,'系统设计','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(278,267,'编译原理','2023-05-05 15:41:55','2023-05-05 15:41:55',0),
(279,0,'资源','2023-05-05 15:41:57','2023-05-05 15:41:57',0),
(280,279,'推荐','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(281,280,'教程','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(282,280,'工具','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(283,280,'项目','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(284,280,'书籍','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(285,280,'GitHub','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(286,280,'前端','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(287,280,'Java','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(288,280,'Python','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(289,280,'测试','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(290,280,'开源','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(291,280,'算法','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(292,280,'人工智能','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(293,280,'Go','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(294,280,'C++','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(295,280,'设计','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(296,280,'软件','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(297,280,'交流社区','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(298,280,'插件','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(299,280,'面经','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(300,279,'编程语言','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(301,300,'Java','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(302,300,'C#','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(303,300,'PHP','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(304,300,'C++','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(305,300,'C语言','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(306,300,'HTML','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(307,300,'CSS','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(308,300,'Javascript','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(309,300,'Go','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(310,300,'Python','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(311,300,'Rust','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(312,300,'Ruby','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(313,300,'Swift','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(314,300,'Scala','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(315,300,'Lua','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(316,300,'Bash','2023-05-05 15:42:00','2023-05-05 15:42:00',0),
(317,300,'Kotlin','2023-05-05 15:42:00','2023-05-05 15:42:00',0);

/*Table structure for table `post` */

DROP TABLE IF EXISTS `post`;

CREATE TABLE `post` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标题',
  `content` text COLLATE utf8mb4_unicode_ci COMMENT '内容',
  `tags` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标签列表（json 数组）',
  `thumbNum` int NOT NULL DEFAULT '0' COMMENT '点赞数',
  `favourNum` int NOT NULL DEFAULT '0' COMMENT '收藏数',
  `userId` bigint NOT NULL COMMENT '创建用户 id',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `isDelete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
  `userName` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `cover` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `description` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `fileList` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `hasFavour` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `hasThumb` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `language` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `needVip` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `pictureList` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `priority` int DEFAULT '0',
  `reviewMessage` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `reviewStatus` int DEFAULT '0',
  `reviewTime` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `reviewerId` bigint DEFAULT NULL,
  `commentNum` int DEFAULT NULL,
  `videoList` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `viewNum` int DEFAULT NULL,
  `PostId` bigint DEFAULT NULL COMMENT '编程导航文章的id',
  PRIMARY KEY (`id`),
  KEY `idx_userId` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=1654747247658786818 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='帖子';

/*Data for the table `post` */

insert  into `post`(`id`,`title`,`content`,`tags`,`thumbNum`,`favourNum`,`userId`,`createTime`,`updateTime`,`isDelete`,`userName`,`cover`,`description`,`fileList`,`hasFavour`,`hasThumb`,`language`,`needVip`,`pictureList`,`priority`,`reviewMessage`,`reviewStatus`,`reviewTime`,`reviewerId`,`commentNum`,`videoList`,`viewNum`,`PostId`) values 
(1638189023954489345,'二分法121','# 专题二：二分法\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/PyoV3oWo-image.png)\n# 前言\n\n本文主要介绍二分法是什么，二分法的原理，二分法的模板以及使用场景，并且会举一些例题和蓝桥杯真题辅助理解。\n\n# 是什么\n\n官方版：二分查找是一个时间效率极高的算法，尤其是面对大量的数据时，其查找效率是极高，时间复杂度是log(n)。 &#x20;\n主要思想就是不断的对半折叠，每次查找都能除去一半的数据量，直到最后将所有不符合条件的结果都去除，只剩下一个符合条件的结果。\n\n精简版：二分区间快速高效找到结果。\n\n# 模板\n\n## 查找大于等于/大于key的第一个元素\n\n这种通常题目描述为满足某种情况的最小的元素。\n\n```cpp\n   int left = 1,right = n;\n    while(left < right)\n    {\n        //这里不需要加1。我们考虑如下的情况，最后只剩下A[i],A[i + 1]。\n        //首先mid = i，如果A[mid] > key，那么right = left = i，跳出循环，如果A[mid] < key，left = right = i + 1跳出循环，所有不会死循环。\n        int mid = (left + right) / 2;\n        if(A[mid] > key)//如果要求大于等于可以加上等于，也可以是check(A[mid])\n            right = mid;\n        //因为找的是大于key的第一个元素，那么比A[mid]大的元素肯定不是第一个大于key的元素，因为A[mid]已经大于key了，所以把mid+1到后面的排除\n        else\n            left = mid + 1;\n        //如果A[mid]小于key的话，那么A[mid]以及比A[mid]小的数都需要排除，因为他们都小于key。不可能是第一个大于等于key的元素，\n    }\n\n```\n\n## 查找小于等于/小于key的最后一个元素\n\n这种通常题目描述为满足某种情况的最大的元素.\n\n```cpp\n    int left = 1, right = n;\n    while(left < right)\n    {\n        //这里mid = (left + right + 1) / 2;\n        //考虑如下一种情况，最后只剩下A[i],A[i + 1]，如果不加1，那么mid = i，如果A[mid] < key，执行更新操作后，left = mid，right = mid + 1，就会是死循环。\n        //加上1后，mid = i + 1,如果A[mid] < key，那么left = right = mid + 1,跳出循环。如果A[mid] > key，left = mid = i，跳出循环。\n        int mid = (left + right + 1) / 2;\n        if(A[mid] < key)\n            left = mid;//如果A[mid]小于key，说明比A[mid]更小的数肯定不是小于key的最大的元素了，所以要排除mid之前的所有元素\n        else\n            right = mid - 1;//如果A[mid]大于key，那么说明A[mid]以及比A[mid]还要大的数都不可能小于key，所以排除A[mid]及其之后的元素。\n    }\n\n\n```\n\n# 判断二分的特性\n\n1.  单调性：数组具有明显的单调性\n2.  二段性：答案在一段区间内，二分答案\n\n# 分类\n\n-   二分查找：在一个已知的有序数据集上进行二分地查找\n-   二分答案：答案有一个区间，在这个区间中二分，直到找到最优答案\n\n# 二分思考顺序\n\n首先通过题目背景和check(mid)函数的逻辑，判断答案落在左半区间还是右半区间。\n\n左右半区间的划分方式一共有两种：\n\n中点mid属于左半区间，则左半区间是\\[l, mid]，右半区间是\\[mid+1, r]，更新方\n\n式是r = mid;或者 l = mid + 1;，此时用第一个模板；\n\n中点mid属于右半区间，则左半区间是\\[l, mid-1]，右半区间是\\[mid, r]，更新方\n\n式是r = mid - 1;或者 l = mid;，此时用第二个模板\n\n（第一个找符合要求的最小值，第二个找符合要求的最大值）\n\n# 力扣704：二分查找\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/eLMZuUV0-image.png)\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n\n        int l=0,r=nums.size()-1;\n        while(l<r){\n            int mid=(l+r)/2;\n            if(nums[mid]>=target) r=mid;\n            else l=mid+1;\n        }\n        if(nums[l]==target) return l;\n        return -1;\n    \n    }\n};\n```\n\n## 题解\n\n本题就是对模板的理解以及运用，属于是二分查找类型，因此用模板1或者模板2都是可以的，并不涉及最大值与最小值的问题。\n\n# 数的范围\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/VwILZO4c-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/3LPGwe53-image.png)\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nint q[N];\nint n,m;\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<n;i++) cin>>q[i];\n    \n    while(m--)\n    {\n        int x;\n        cin>>x;\n        int l=0,r=n-1;\n        while(l<r)\n        {\n            int mid=l+r >>1;\n            if(q[mid]>=x) r=mid;\n            else l=mid+1;\n        }\n        \n        if(q[l]!=x) cout<<\"-1 -1\"<<endl;\n        else{\n            cout<<l<<\" \";\n            int l=0,r=n-1;\n            while(l<r)\n            {\n                int mid=l+r+1>>1;\n                if(q[mid]<=x) l=mid;\n                else r=mid-1;\n            }\n            \n            cout<<l<<endl;\n        }\n    }\n}\n```\n\n## 题解\n\n本题中的“起始位置”以及“最终位置”就分别对应最小值和最大值，因此对模板的理解要到位，第一个模板更新r向左边找的是找出最小值，第二个则是最大值，当然有可能是相等的情况以及找不到的情况。\n\n# 我在哪？\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/aTHXcf00-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/nyvEe7sI-image.png)\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nstring str;\nunordered_set<string> S;\n\n//找到任何两个长度为k的子串都不互相同\n//知识点：判断某个串是否只出现一次可以用哈希表\n\nbool check(int mid)\n{\n    for(int i=0;i+mid-1<n;i++)//区间大小为mid\n    {\n        string s=str.substr(i,mid);//取出子串\n        if(S.count(s)) return false;\n        S.insert(s);\n    }\n    \n    return true;\n}\n    \nint main()\n{\n    cin>>n;\n    cin>>str;\n    int l=1,r=n;//答案的区间\n    while(l<r)\n    {\n        int mid=l+r >> 1;\n        if(check(mid)) r=mid;\n        else l=mid+1;\n    }\n    \n    cout<<l<<endl;\n}\n```\n\n## 题解\n\n注意到本题属于是二分答案类型，答案是在一个区间里的，再根据题意要求出最小值选用第一个模板即可，\n\n本题需要掌握一个哈希表的知识点，可以用来快速判重，下次出一个专门的stl使用技巧，总结出所有常用的库以及函数。\n\n思维点：找到任何两个长度为k的子串都不互相同\n\n# 分巧克力\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/Izt9iZJu-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/uXAWWkrU-image.png)\n\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nint w[N], h[N];//存储长、宽\nint n,k;\n//因为答案在一个区间内：具有二段性，因此可以用二分答案法。\n\nbool check(int a){\n    int num=0;//切出的数量\n    for(int i=0;i<n;i++)\n    {\n        num+=(w[i]/a)*(h[i]/a);//推出的公式\n        if(num>=k) return true;\n    }\n    \n    return false;\n}\n\n\nint main()\n{\n    cin>>n>>k;\n    for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n    \n    int l=1,r=1e5;//答案的区间\n    while(l<r)\n    {\n        int mid=(l+r+1) >>1;\n        if(check(mid)) l=mid;//因为求最大值\n        else r=mid-1;\n    }\n    \n    cout<<r<<endl;\n    return 0;\n}\n```\n\n## 题解\n\n本题注意到随着边长的增加，分的块数就会减小，满足单调递减的性质，考虑用二分出最大的边长。\n\n且答案在一个区间内，因此可以用二分答案的方法，再根据题目求最大值来选出用第二个模板。\n\n本题还需要推出一个可以切出巧克力块数的公式。\n\n# 机器人跳跃问题\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/PqcPTKO8-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/3lq1kLSC-image.png)\n\n## 代码\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n;\nint h[N];\n\nbool check(int e)\n{\n    for (int i = 1; i <= n; i ++ )\n    {\n        e + = e - h[i];//每次失去或者得到能量\n       if (e >= 1e5) return true;//需要注意超过能量最大值的特判\n        if (e < 0) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i ++ ) scanf(\"%d\", &h[i]);\n\n    int l = 0, r = 1e5;//\n    while (l < r)\n    {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;\n        else l = mid + 1;\n    }\n\n    printf(\"%d\\n\", r);\n\n    return 0;\n}\n\n\n\n```\n\n## 题解\n\n本题还是有一定难度的，首先你需要想到可以用二分答案法来写，因为答案在一个区间内，并且不管你是得到还是失去能量都可以用一个表达式来表示，只不过可以是正也可以负值罢了，再去判断是否有一步走了会小于0，如果小于0了就不符合。本题还需要注意不能超出能量最大值。\n\n# 总结\n\n本文主要介绍了二分法，重点需要掌握二分的两个模板和理解方法，灵活运用到题目中还需大家多做题，增加自己的理解力和敏锐度。预祝各位考出好成绩！\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/d6g5W32F-image.png)','[\"文章\",\"蓝桥杯\"]',0,0,1,'2023-03-21 22:41:13','2023-03-31 14:19:39',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1638189024264867841,'专题一：日期问题','# 前言\n\n在专题一种我们主要讲解关于日期的问题，比较基础但是一定要掌握！！在**蓝桥杯**竞赛中，常会考到一些日期日历的问题，出现在填空题或者编程的前几题，因此巩固好基础更加有助于我们在比赛中遇到类似的题时游刃有余。下面来枚举一些例题与蓝桥杯的真题。格式会按照：**题目—题解—知识点**，十分清晰！！废话不多说，先上模板！！\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/uh5Cu2jY-image.png)\n\n# 模板\n\n非常重要！！可以说**背下来**可以做出来％90的日期日历的问题！\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n// 判断日期的合法性\nbool check_valid(int date) //形如20210305\n{\n    int year = date / 10000;\n    int month = date % 10000 / 100;\n    int day = date % 100;\n\n    if (month <= 0 || month >= 13) return false;\n    if (day == 0 || month != 2 && day > months[month]) return false;\n\n    if (month == 2)\n    {\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        if (day > 28 + leap) return false;\n    }\n\n    return true;\n}\n\n// 得到某年某月的天数\nint get(int year, int month) \n{\n    if (month != 2) return months[month];\n    else\n    {\n        // 2月\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        return 28 + leap;\n    }\n}\n\n// 判断两个日期之间有多少个回文日期\nint get(int date1, int date2, int k) //k使函数签名不同从而编译通过\n{\n    int ans = 0;\n    for (int i = 1000; i < 10000; i++)\n    {\n        int date = i, x = i;\n        for (int j = 0; j < 4; j++) date = date * 10 + x % 10, x /= 10; //根据年份构造出回文日期\n        if (date1 <= date && date <= date2 && check_valid(date)) ans++; \n    }\n\n    return ans;\n}\n\n// 给定年月日，经过n天后对应的日期\nvoid pass(int y, int m, int d, int n)\n{\n    while (n--)\n    {\n        d++;\n        if (d > get(y, m)) m++, d = 1;\n        if (m > 12) y++, m = 1;\n    }\n    printf(\"%d-%02d-%02d\\n\", y, m, d);\n}\n\n\n\n```\n\n\n\n# 1、回文日期-1\n\n\n\n![image_8DQXwLdh4f.png](https://pic.code-nav.cn/post_picture/1612112775822180354/i0qkvjFW-image_8DQXwLdh4f.png)\n\n![image_F5qCyEFE0r.png](https://pic.code-nav.cn/post_picture/1612112775822180354/KkZ8UvYj-image_F5qCyEFE0r.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n//判断日期是否合法的模板，背诵！！\nbool check(int date)\n{\n    int year=date/10000;\n    int month= date%10000/100;\n    int day = date%100;\n \n    if(!month||month>=13||!day) return false;\n    if(month!=2&&day>months[month]) return false;\n \n    if(month==2)\n    {\n        bool leap = year%4==0 &&year %100!=0 || year %400==0;\n        if(day>leap+28) return false;\n    }\n \n    return true;\n}\n\n\nint main()\n{\n    int data1,data2;\n    cin>>data1>>data2;\n \n    int res=0;\n    for(int i=0;i<10000;i++)\n        {\n            int x=i,r=i;\n            for(int j=0;j<4;j++) r=r*10+x%10,x=x/10;//回文串转换的算法\n            if(r>=data1&& r<=data2 && check(r)) res++;\n        }\n    cout<<res<<endl;\n    return 0;\n}\n\n```\n\n## 题解\n\n由于只有八位数，且回文串左右对称，因此可以只枚举左边，这样只需要枚举0~9999\n\n然后判断：\n\n1. 整个八位数构成的日期是否合法\n2. 是否在范围内\n\n**本题思维在于枚举所有回文数再去筛选出符合要求的。**\n\n知识点：\n\n1. 判断日期是否合法的模板\n2. 回文串转换算法\n\n\n\n# 2、日期识别\n\n![image_kw0EJjwrmn.png](https://pic.code-nav.cn/post_picture/1612112775822180354/pJkhQ91H-image_kw0EJjwrmn.png)\n\n![image_wTHGGecViR.png](https://pic.code-nav.cn/post_picture/1612112775822180354/u0Uo5MA9-image_wTHGGecViR.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstring month[13]={\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nint main()\n{\n   string st;\n   int m,d1,d2;\n   cin>>st;\n   for(int i=1;i<=12;i++)\n        if(st.substr(0,3)==month[i])\n        {\n            m=i;\n            break;\n        }\n    d1=st[3]-\'0\';\n    d2=st[4]-\'0\';\n    cout<<m<<\" \";\n    if(d1!=0) cout<<d1;\n    cout<< d2;\n}\n```\n\n## 题解\n\n本题主要就是枚举，再加上一些字符串处理的知识，并没有什么思维上的难度。\n\n知识点：\n\n1. substr函数：返回从某个位置后指定长度的子串\n2. 字符转成数字的操作\n\n\n\n# 3、日期类\n\n\n![image_xkj-5iiRs9.png](https://pic.code-nav.cn/post_picture/1612112775822180354/ArlJGuci-image_xkj-5iiRs9.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint main()\n{\n    int n,y,m,d;\n    cin>>n;\n    while(n--){\n        cin>>y>>m>>d;\n        if(y%4==0&&y%100!=0||y%400==0)a[2]=29;\n        else a[2]=28;\n        d++;\n        if(d>a[m]){\n            m++;\n            d=1;\n        }\n        if(m>12){\n            m=1;\n            y++;\n        }\n        if(y<10)cout<<0;\n        cout<<y<<\'-\';\n        if(m<10)cout<<0;\n        cout<<m<<\'-\';\n        if(d<10)cout<<0;\n        cout<<d;\n        cout<<endl;\n    } \n    return 0;\n}\n\n```\n\n## 题解\n\n变量是：y=year m=month  d=day\n\n然后我们判断，只要我们的天数大于了这个月的天数，我们就要把月份m++，并且把日回到1号\n同理只要我们的月数大于了12，我们就要把年份y++，并且把月份回到1月\n\n接下来我们还要考虑一个问题，就是一位数前加0（输出格式）\n我们只要一次判断即可：只要y是一位数，先输出个0，日也是一样的做法。\n\n知识点：\n\n1. 算天数模板的运用\n2. 判断闰年\n\n\n\n\n\n# 4、打印日期\n\n\n![image_UxZ4jtKlmW.png](https://pic.code-nav.cn/post_picture/1612112775822180354/WY21mNXp-image_UxZ4jtKlmW.png)\n\n\n![image_ixcooYY5Yp.png](https://pic.code-nav.cn/post_picture/1612112775822180354/2Tfzyjkc-image_ixcooYY5Yp.png)\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint main()\n{\n    int y,d;\n    //输入多行数据\n    while(cin>>y>>d){\n        //获得二月的天数\n        if(y%4==0&&y%100!=0||y%400==0)a[2]=29;\n        else a[2]=28;\n        int m=1;\n        while(d>0){\n            if(d-a[m]<=0)break;\n            else{\n                d-=a[m];\n                m++;\n            }\n        }\n        printf(\"%04d-%02d-%02d\\n\",y,m,d);//数据宽度不足时用0填补\n    }\n}\n\n```\n\n## 题解\n\n先把每个月的天数给列下来，再判断闰年。\n最后我们来统计是几月几日，如果减去m月的天数，就比0要小了，我们就赶快退出\n如果不会的话，月份+1，并且减去m月的天数。\n\n知识点：\n\n1. 格式输出大法：printf(\"%04d-%02d-%02d\\n\",y,m,d);\n2. 判断闰年\n\n\n\n\n\n# 5、日期\n\n\n![image_5wlbv3TwGD.png](https://pic.code-nav.cn/post_picture/1612112775822180354/MR1FvJa0-image_5wlbv3TwGD.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};\nstring week[7]={\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",};\nint main()\n{\n    int n,m,day1=0,day2=0;\n    cin>>n>>m;\n    for(int i=1;i<4;i++)day1+=a[i];\n    day1+=12;\n    for(int i=1;i<n;i++)day2+=a[i];\n    day2+=m;\n    cout<<week[(day2-day1)%7];\n}\n\n```\n\n## 题解\n\n本题思维点在于把星期四当成第一天，然后计算出给出的日期与第一天的差值，再利用取模的算法求出是星期几，如果对取模算法不熟悉的话需要自行在草稿纸上模拟一遍，并记下这个结论。\n\n知识点：\n\n1. 打表，将星期四作为第一天\n2. 取模运算求出是星期几\n\n\n\n\n\n# 6、日期计算\n\n\n![image_plw0op1pYi.png](https://pic.code-nav.cn/post_picture/1612112775822180354/4bd7A55f-image_plw0op1pYi.png)\n\n![image_nCOo4tQrC-.png](https://pic.code-nav.cn/post_picture/1612112775822180354/ZYpfRM27-image_nCOo4tQrC-.png)\n## 代码\n\n### 解法一：模板法\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n// 得到某年某月的天数\nint get(int year, int month)\n{\n    if (month != 2) return months[month];\n    else\n    {\n        // 2月\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        return 28 + leap;\n    }\n}\n\n// 给定年月日，经过n天后对应的日期\nvoid pass(int y, int m, int d, int n)\n{\n    while (n--)\n    {\n        d++;\n        if (d > get(y, m)) m++, d = 1;\n        if (m > 12) y++, m = 1;\n    }\n    printf(\"%d\\n%d\\n\", m, d);\n}\n\nint main()\n{\n    int y, n;\n    cin >> y >> n;\n    int m = 1, d = 0;\n    pass(y, 1, d, n);\n    return 0;\n}\n\n\n```\n\n### 思维法：\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint main()\n{\n    int y,d;\n    cin>>y>>d;\n    if(y%4==0&&y%100!=0||y%400==0)a[2]=29;else a[2]=28;\n    int x=0;\n    while(d>0){\n        if(d-a[x]<=0)break;\n        else{\n            d-=a[x];\n            x++;\n        }\n    }\n    cout<<x<<\'\\n\'<<d;\n}\n\n\n```\n\n## 题解\n\n本题考察日期计算的方法，可以套用模板，也可以用思维法减少代码量，看个人喜好。\n\n知识点：\n\n1. 得到某年某月某日的天数\n2. 计算给定年月日，经过n天后对应的日期\n\n\n\n# 7、特殊年份—蓝桥杯十二届真题\n\n\n![image_xATHh4b7-k.png](https://pic.code-nav.cn/post_picture/1612112775822180354/K3BttOjX-image_xATHh4b7-k.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int count=0;\n    for(int i=0;i<5;i++)\n    {\n        string s;\n        cin>>s;\n        if(s[0]==s[2]&&s[3]-s[1]==1)\n        {\n            count++;\n        }\n    }\n \n \n    cout<<count<<endl;\n \n}\n```\n\n## 题解\n\n水题一套，只要会字符串处理即可AC\n\n\n\n# 7、回文日期-2\n\n\n![image_gN7OPu6RwK.png](https://pic.code-nav.cn/post_picture/1612112775822180354/5Q9RmDCt-image_gN7OPu6RwK.png)\n\n![image_eT1jL6BF79.png](https://pic.code-nav.cn/post_picture/1612112775822180354/1PTpuzFI-image_eT1jL6BF79.png)\n## 代码\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n// 判断日期的合法性\nbool check_valid(int date) \n{\n    int year = date / 10000;\n    int month = date % 10000 / 100;\n    int day = date % 100;\n\n    if (month <= 0 || month >= 13) return false;\n    if (day == 0 || month != 2 && day > months[month]) return false;\n\n    if (month == 2)\n    {\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        if (day > 28 + leap) return false;\n    }\n\n    return true;\n}\n\n// 判断date是否满足ABABBABA形式\nbool check(int date)\n{\n    int year = date / 10000;\n    int month = date % 10000 / 100;\n    int day = date % 100;\n\n\n    if (month % 10 == day / 10) return false; //A==B return false\n    if ((month % 10 == day % 10) && (month / 10 == day / 10)) return true;\n\n    return false;\n}\n\nbool st1, st2;\nint ans1, ans2;\n\nint main()\n{\n    int date;\n    cin >> date;\n\n    int year = date / 10000;\n    while (true)\n    {\n        int new_date = year, x = year;\n        for (int i = 0; i < 4; i++) new_date = new_date * 10 + x % 10, x /= 10; //构造回文日期\n\n        if (new_date == date)  //构造出来的是同一天\n        {\n            year++;\n            continue;    \n        }\n\n        if (check_valid(new_date))\n        {\n            if (!st1) st1 = true, ans1 = new_date;\n            if (!st2 && check(new_date)) st2 = true, ans2 = new_date;\n\n        }\n\n        year ++;\n        if (st1 && st2) break; //找到两个解则退出\n    }\n\n    printf(\"%d\\n%d\", ans1, ans2);\n    return 0;\n}\n\n\n```\n\n## 题解\n\n本题需要找到两个符合题目的答案，第一个是回文子串，第二个符合格式的回文子串。\n\n先构造回文子串\n\n用函数判断是不是合法日期，如果不是就跳到下一个。\n如果符合，那么第一个答案已经找到，即可标记为true，在去判断是否符合格式.\n\n最后找到两个答案就输出即可。\n\n知识点：\n\n1. 回文子串构造\n2. 判断合法日期\n3. 判断是否符合格式\n\n\n\n# 总结\n\n以上的题基本包含了所有会考到的日期日历问题，各位一定要**先把模板背熟**，再去**写例题**，不会的题一定要\n\n好好琢磨题解的思维以及需要掌握的知识点是否已经烂熟于心。开篇大吉，预祝各位考生考出好成绩！！\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/jxux7Zb3-image.png)\n\n','[\"文章\",\"蓝桥杯\"]',0,0,1,'2023-03-21 22:41:13','2023-03-21 22:41:13',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1638189024264867842,'快速通过软考11','\n![f8af55a9c0104edd85bfb0988b70511.jpg](https://pic.code-nav.cn/post_picture/1612112775822180354/gSmF2r0p-f8af55a9c0104edd85bfb0988b70511.jpg)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2ed16e5b7ad74d439fde93802c836a91.png#pic_center)\n\n# 什么是软考？\n\n软考全称“计算机技术与软件专业技术资格（水平）考试”，由国家人力资源和社会保障部、工业和信息化部领 导下的国家级考试，设置了27个资格包括初级、中级、高级三个级别。官网地址如下：\n\n<https://www.ruankao.org.cn/>\n\n# 软考的含金量与意义\n\n1.  软考证书每月都有补贴，不仅国企和事业单位，甚至普通公司也会补贴。并且获取软考证书可以补税退税。\n2.  软考是国家级考试。通过软考中高级考试，就是国家认定的中高级技术人员。国家很多政策优惠在计算机领域只认软考。而国外的那些证书（OCP数据库认证、思科认证）是不能享受优惠政策的。软考能够积分落户、退休金补贴、个税补贴、申请廉租房......。。软考证书可以抵扣个税，大概可以少交1500元的个人所得税。\n3.  软考的知识点覆盖面十分广泛，基本会设计到软件开发的所有需要掌握的理论知识，比如设计模式、\n\n    软件工程、数据库、计算机网络、操作系统、计算机组成原理等计算机科班所必须学习的知识，因此非常适合了解该专业的一个系统的框架以及深入理解一些理论知识。\n\n# 正常备考节奏\n\n# 备考时长\n\n首先去官网买一本你所要考的等级的官方用书，我这边就以我通过的中级软件设计师来举例了，然后再购买近五年的上下班年的真题试卷结合着下面up主的视频来学习，大概需要三个月的时长。\n\n## 学习路线\n\n推荐一个up主的视频，非常细致且好理解，如果能完完整整地跟着学完一定能够高分通过！！\n\n<https://www.bilibili.com/read/cv18526892>\n\n\n## 推荐笔记\n[笔记](<https://blog.csdn.net/apple_53947466/article/details/125557473?app_version=5.7.3&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125557473%22%2C%22source%22%3A%22apple_53947466%22%7D&utm_source=app>)\n\n## 高频考点\n [考点1](<https://blog.csdn.net/m0_64128218/article/details/127291829?app_version=5.9.0&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127291829%22%2C%22source%22%3A%22m0_64128218%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app>)\n \n[考点2](<https://blog.csdn.net/m0_64128218/article/details/127289970?app_version=5.9.0&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127289970%22%2C%22source%22%3A%22m0_64128218%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app>)\n\n\n# 重要考点\n\n自己从刷的题中总结出来的知识点。你们遇到了自然就能懂是什么意思了，对照着知识点去回忆知识是一种很高效的查漏补缺的办法。\n\n-   寻址方式\n-   总线\n-   流水线\n-   中断（DMA）\n-   存储器（RAM flesh cache）\n-   原码、补码、阶码\n-   防火墙  网络安全知识\n-   加密算法（公开，私有（共享）） 非对称\n-   软著、商业秘密、著作权\n-   数据流图\n-   软件设计原则\n-   风险检测\n-   活动图\n-   符号表、决策表、广义表\n-   有限自动机\n-   进程状态\n-   页面管理 &#x20;\n-   PV图\n-   死锁算法公式\n-   磁盘旋转算法\n-   增量模型、瀑布模型、螺旋模型\n-   统一过程up\n-   敏捷开发的五个原则\n-   ISO IEC 9126软件质量模型的六个特性\n-   系统测试\n-   系统分析\n-   概要设计、详细设计\n-   系统文档—用户与系统分析人员\n-   白盒测试—语句覆盖\n-   系统的可维护性\n-   软件评审\n-   面向对象分析步骤、设计原则\n-   UML关系：关联关系  UML各种图：状态图\n-   设计模式：中介者、策略\n-   数据库：三种模式、特殊符号含义\n-   栈、循环队列、双端队列、各种二叉树特性和公式、拓扑排序、哈夫曼树\n-   各种排序（归并、快速）的时空复杂度表、稳定性\n-   路由、ARP、网关\n-   编译程序的各种分析\n-   耦合的各种类型  内聚类型\n\n# 个人经验\n\n我开始准备软件设计师考试的时候其实距离考试时间仅仅一周多了，虽然最后考的分不高，但是也是稳稳地通过拿证了。那么如何在一周内完整突击呢？必须把仅五年的真题你所能掌握的每一道题做上三遍，**第一遍是闭卷写题，第二遍是对照着答案以及知识点笔记去记忆，第三遍是看错题**，注意上午是考选择题的，你做的题越多，出现原题的可能性就越大，考的基本都是类似的知识点，不需要去做一些额外的模拟题。而下午题是大题，考法非常的固定，算法题不会的话可以直接放弃，因为其他几道题做好已经能保证你高分通过了。考前就带着你的错题集或者试卷集去看，加深映象会发现考试的时候基本都是你碰到过得题型。\n\n最后大家如果需要我写的笔记或者有问题咨询的话可以在评论区留言！祝大家考出好成绩！！&#x20;','[\"文章\",\"软考\"]',0,0,1,'2023-03-21 22:41:13','2023-03-31 00:45:55',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1638189024264867843,'Git使用指南22','### 1、了解Git的基本概念\n\n在学习Git之前，需要了解Git的基本概念。下面是一些术语：\n\n- 仓库（`Repository`）：Git用仓库来存储代码，仓库可以保存所有的版本历史记录。\n- 分支（`Branch`）：分支是Git中一个重要的概念。通过创建分支，你可以在代码的不同版本之间切换。\n- 提交（`Commit`）：在Git中，每次对代码进行的更改都需要提交。提交可以记录下当前代码的状态，并保存在Git的历史记录中。\n- 合并（`Merge`）：在Git中，你可以合并不同的分支，将它们合并成一个版本。\n- 远程仓库（`Remote Repository`）：远程仓库是指存储在其他计算机或服务器上的Git仓库。你可以通过Git与远程仓库进行交互，例如推送代码、拉取代码等。\n\n### 2、安装Git\n\n在学习Git之前，需要先安装Git。Git可以在`Windows`、`Linux`和`MacOS`等操作系统上运行。可以通过以下链接下载Git并安装：\n\n- Windows: https://git-scm.com/download/win\n- MacOS: https://git-scm.com/download/mac\n- Linux: https://git-scm.com/download/linux\n\n安装完成后，可以在命令行中输入`git --version`来检查Git是否安装成功。\n\n### 3、学习Git的命令行界面\n\nGit可以通过命令行界面进行交互。下面是一些常用的Git命令：\n\n- `git init`：初始化一个新的Git仓库。\n- `git add <file>`：将一个文件添加到Git的暂存区。\n- `git commit -m \"<message>\"`：将暂存区的文件提交到Git仓库，并附带一条提交信息。\n- `git push`：将本地仓库中的代码推送到远程仓库。\n- `git pull`：从远程仓库拉取最新的代码到本地仓库。\n- `git status`：查看当前仓库的状态，包括哪些文件已修改、哪些文件已经添加到暂存区等等。\n- `git log`：查看提交历史记录。\n\n### 4、使用Git的可视化界面工具\n\n除了命令行界面，Git还提供了一些可视化界面工具，如`GitHub Desktop`、`GitKraken`等等。这些工具可以帮助你更方便地使用Git，特别是对于初学者来说。可以在它们的官方网站上下载并安装，然后使用它们来管理你的Git仓库。\n\n### 5、练习Git的使用\n\n最好的学习方法就是实践。可以创建一个Git仓库，尝试添加文件、提交变更、合并分支等等，来熟悉Git的使用。在实践中，可以先创建一个本地仓库，然后尝试使用Git命令行界面或者可视化界面工具对仓库进行管理。下面是一些练习的建议：\n\n- 创建一个新的仓库，并将代码添加到仓库中。\n- 创建一个新的分支，并在分支中进行代码修改。\n- 将修改后的分支合并到主分支中。\n- 将代码推送到远程仓库中。\n\n此外，还可以参与开源项目，学习如何与其他开发者协作使用Git。GitHub是一个非常流行的开源代码托管平台，可以在上面找到许多有趣的项目来学习和参与。\n\n**总结：** 学习Git需要花费一定的时间和精力，但它是现代软件开发不可或缺的工具。通过不断的练习和实践，逐渐熟悉Git的使用，并在软件开发中发挥重要的作用。\n\nGit已经成为前端入门必须掌握的技能，从HTML阶段到网页布局项目实战都需要用到。','[\"文章\",\"前端\",\"工具\",\"教程\"]',0,0,1,'2023-03-21 22:41:13','2023-03-31 00:38:36',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1638189024264867844,'前端 JavaScript 与 HTML 怎么实现交互','前端 JavaScript 和 HTML 可以通过事件监听器、DOM 操作、Ajax、表单交互、动态创建和修改 HTML 元素等方式实现交互；具体的实现方式如下：\n\n# 1、事件监听器\n\nJavaScript 可以在 HTML 元素上设置事件监听器，以便在特定事件（例如单击、鼠标悬停或键盘敲击）发生时触发 JavaScript 代码。\n\n例如，以下代码段演示了如何在 HTML 元素上设置单击事件监听器：\n\n```js\n<button onclick=\"myFunction()\">Click me</button>\n\n<script>\nfunction myFunction() {\n alert(\"Hello World!\");\n}\n</script>\n```\n\n# 2、DOM 操作\n\nJavaScript 可以使用 Document Object Model (DOM) 操作 HTML 元素。DOM 是一种表示 HTML 页面的树形结构，可以使用 JavaScript 修改 HTML 元素的内容、属性和样式。\n\n例如，以下代码段演示了如何使用 JavaScript 获取 HTML 元素的值并将其更改为新值：\n\n```js\n<p id=\"demo\">Hello World!</p>\n\n<script>\nvar x = document.getElementById(\"demo\");\nx.innerHTML = \"Hello JavaScript!\";\n</script>\n```\n\n# 3、Ajax\n\nAjax 是一种使用 JavaScript 发送和接收数据的技术。它可以使 Web 应用程序与服务器进行交互，而无需刷新整个页面。\n\n例如，以下代码段演示了如何使用 Ajax 发送 GET 请求并在 HTML 页面上显示响应数据：\n\n```js\n<button onclick=\"loadDoc()\">Click me</button>\n\n<script>\nfunction loadDoc() {\n var xhttp = new XMLHttpRequest();\n xhttp.onreadystatechange = function() {\n   if (this.readyState == 4 && this.status == 200) {\n     document.getElementById(\"demo\").innerHTML = this.responseText;\n  }\n};\n xhttp.open(\"GET\", \"ajax_info.txt\", true);\n xhttp.send();\n}\n</script>\n```\n\n# 4、表单交互：\n\nHTML 中的表单元素（例如输入框、下拉列表、复选框等）可以与 JavaScript 进行交互。JavaScript 可以在表单元素上设置事件监听器，并读取或修改表单元素的值。\n\n例如，以下代码段演示了如何使用 JavaScript 获取表单元素的值：\n\n```js\n<form>\n <label for=\"name\">Name:</label>\n <input type=\"text\" id=\"name\" name=\"name\"><br><br>\n <button type=\"button\" onclick=\"myFunction()\">Submit</button>\n</form>\n\n<script>\nfunction myFunction() {\n var name = document.getElementById(\"name\").value;\n alert(\"Hello \" + name + \"!\");\n}\n</script>\n```\n\n# 5、动态创建和修改 HTML 元素：\n\nJavaScript 可以动态创建和修改 HTML 元素，从而实现动态页面效果。例如，JavaScript 可以在页面上添加新元素、更改元素的样式、更改元素的内容等等。\n\n例如，以下代码段演示了如何使用 JavaScript 动态创建一个新的段落元素，并将其添加到页面中：\n\n```js\n<button onclick=\"myFunction()\">Add Paragraph</button>\n\n<script>\nfunction myFunction() {\n var para = document.createElement(\"p\");\n var node = document.createTextNode(\"This is a new paragraph.\");\n para.appendChild(node);\n\n var element = document.getElementById(\"div1\");\n element.appendChild(para);\n}\n</script>\n```\n\n以上是 JavaScript 和 HTML 实现交互的一些常见方式。通过使用这些技术，开发人员可以创建动态、交互式的 Web 应用程序。','[\"文章\",\"前端\",\"Javascript\"]',0,0,1,'2023-03-21 22:41:13','2023-03-21 22:41:13',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1638189024264867845,'编程导航建议反馈','欢迎朋友们在评论区分享对网站的看法和建议、指出网站的 Bug 和不足、给我们提需求加功能等等。。。\n\n我们会精选部分有价值的反馈和建议（被精选可以获得积分奖励），努力持续改进，争取给大家提供更好的服务和体验。谢谢大家！','[\"文章\"]',0,0,1,'2023-03-21 22:41:13','2023-03-21 22:41:13',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1638189024264867846,'chatGPT大火，来看看chatGPT的创始人对于程序员成功的分享','## 《程序员的成功之路》\n> - 如果你觉得文字读起来太累：https://www.bilibili.com/video/BV1bs4y1a7B7/?spm_id_from=333.337.search-card.all.click&vd_source=ce628a5bd43df277d141676215ef5ff3\n> - 如果你想阅读英文原文：http://blog.samaltman.com/how-to-be-successful\n\n### 1.选择复利增长\n复利具有神奇的魔力，现在处处都在强调复利，这其中的奥秘就是指数曲线，因为指数曲线是创造财富的关键。一家中型企业的价值如果按照每年50%的速度增长，那么它的规模可以在短时间内极速扩张。世界上少有企业具有真正的网络效应和高度的可扩展性，但是随着技术进步，这种情况会逐渐改变，这值得我们不断为之努力。\n\n对个体的人生道路来说，我们也应该走成一条指数曲线。也就是说，我们要遵循不断向右增长的人生轨迹。在进行职业规划时，要选择具有复合效应的职业，而大多数职业的发展轨迹都是一条线性直线。\n\n在线性职业领域，工作二十年的效率并不会比工作两年的效率高，像这样的职业不利于个人发展。\n\n我们需要的是一份能保持不断学习的职业。随着职业发展，我们需要产出越来越多的成果。达成这一目标的途径多种多样，比如说资本、技术、品牌、网络效应和做管理。\n\n专注于将你所定义的成功指标增加十倍是有用的，这些指标可以是赚钱、社会地位、世界级影响力或者其他东西。我乐意接受挑战，愿意在各种项目上花时间以解锁下一个项目。但是我希望在每一个项目上都能取得最大成就，创造职业生涯新高度。但是大多数人都被困于线性发展的泥潭，往往捡了芝麻丢了西瓜，我们要学会抓大放小，寻求跳跃式提升。\n\n在我看来，无论是企业还是个人，最大的竞争优势就是要把目标放长远。我们要打开眼界，看出世界上不同体系之间交融互动的方式。复合增长最重要的就是眼光要尽可能放长远，这样的人才能抢占市场先机，获得最大回报。\n\n要相信指数曲线，耐心坚持下去，最后一定会有惊喜。\n\n### 2.要有绝对自信\n自信拥有不可思议的力量，就我认识的人来说，最成功的往往都是那些自信到离谱的人。\n\n我们要尽早树立自信。如果你的判断常常都很准确，能带来很好的结果，那么你一定要加倍自信。\n\n对自己不自信的人很难对未来抱有逆向思维，但是往往逆向思维才能创造出最大的价值。还记得很多年前马斯克带我参观SpaceX工厂，他详细地谈到了制造火箭的一些细节，但是让我印象最深的还是马斯克谈到向火星发射火箭时的表情，离开工厂时我就在想 “啊，这就是自信的样子”。\n\n对大多数创业者来说，激发自己以及团队的士气可以说是最大的挑战之一，如果没有自信，这就成了几乎不可能完成的任务。但往往一个人越有雄心壮志，其受到的打击就会越多。大多数非常成功的人在面对人们的质疑时至少有一次决定是正确的，否则他们面临的挑战会更多。\n\n我们在自信的同时也要保持清醒的自我认知，才能避免盲目自大。我曾经非常讨厌受到批评和质疑，并且总是设法规避这些批评。但现在我开始尝试听取这些意见，我会先设想这些批评是正确的，然后在这个基础上调整我的计划。做决定的过程充满了艰辛和痛苦，但也只有经历了这个过程才能将自信和自欺欺人区分开来。\n\n保持自信与自我认知之间的平衡可以让人免于傲气、避免与他人脱节。\n\n### 3.学会独立思考\n创业很难，因为培养原创性思维很难。这种思维在学校里面是学不到的，实际上学校培养的是一种相反的思维方式，所以只能靠我们自己来培养原创性思维。\n\n我们可以从第一性原理(first principles) 出发，从中想出新的点子，然后与人交流沟通，对这些想法进行改良，之后我们再用轻松快捷的方式进行实际测试。\n\n对创业者来说，失败是家常便饭，但我们一定要抱有必胜的信念，要不断尝试、不断试错，只有这样才能得到幸运之神的眷顾。在这个过程中，最宝贵的经验之一就是，我们要学会在绝境中找到一线生机。我们经历的越多就会越对此深信不疑。要知道勇气来自于多次失败后的坚持不懈。\n\n### 4.做一个好销售\n光有自信是不够的，我们还要具备说服他人的能力。就某种程度来说，所有职业的本质都是销售。你必须向客户、潜在职员、媒体、投资者等宣传兜售你的计划。想要说服他们，首先你的计划要有广阔的发展前景。对于个人而言，你要具备良好的沟通能力、一定的个人魅力以及强大的执行能力。\n\n具备良好的沟通能力十分重要，尤其是书面沟通。在这方面我的建议是：首先要保持思路清晰，然后就是尽量使用简洁明了的语言。\n\n而要做好“销售”最好的方式就是真诚，要对自己推销的产品抱有自信。销售其实无异于其他技能，我们可以通过可以练习提高销售技能。但是出于某些原因（比如人们可能不喜欢销售），很多人认为销售技能不可习得。\n\n做销售的另一个秘诀是:重要的事情要亲力亲为。在刚开始创业时，我非常乐意出差办事，这在很多人看来是不必要的，但是事事亲力亲为却给我带来了三次职业生涯的转折点，如果当时没有选择这样做，我可能会走上另一条道路。\n\n### 5.要有冒险精神\n大多数人往往都高估了风险低估了回报。冒险对我们来说也很重要，因为人不可能永远不犯错，我们需要不断试错，学习并快速适应。\n\n在职业生涯早期，人们往往更愿意冒险，因为那时你没有什么可失去的东西，但却可能得到很多。一旦一个人履行了自己的基本责任义务，就可以大胆冒险了。我篇幅可以先下小的赌注，如果赌输了会输掉1倍，但如果成功了，则可以赚到100倍。之后我们再沿着这个方向下更大的赌注。\n\n但是要注意不能一直待在舒适圈。在YC，我们从谷歌和脸书长期工作的创始人身上看到了这样一个问题：当人们习惯了舒适的生活、稳定的工作和无论做什么都会取得成功的名气时，就很难将这些置之于身后了（人们总是将他们的生活方式与下一年的工资相匹配）。即使他们真的离开了，也非常有可能再回来。与长期利益相比，短期诱惑和便利往往更具吸引力，也更符合人的天性。\n\n但当你摆脱了这些枯燥无味的工作，你可以跟随直觉将时间花在那些有趣的事情上。而想做到这一点，尽可能长时间地过着朴素灵动的生活是一个很好的方法。当然，任何选择背后都有相应的代价。\n\n### 6.保持专注\n专注可以让我们在工作中取得事半功倍的效果。磨刀不误砍柴工，在我认识的人中，那些花时间想明白了未来方向的人最后都得到了不错的结果。由此可见，做正确的事比长时间做事更重要。很多人都将自己的时间花在了无关紧要的事情上面。\n\n一旦你想明白了该做什么，就不要犹豫，快速行动起来去完成优先事项。毕竟成功人士就没有执行力弱的。\n\n### 7.努力工作\n通过运用自己的聪明才智或者勤奋努力，一个人可以达成工作领域里百分之九十的成就，能做到这一点已经很不错了，但是想要尽量做到完美，达成百分之九十九的成就，那就必须要兼顾聪明与勤奋，因为这一阶段你的竞争者往往是两者兼备的人。\n\n有付出才有收获，付出越多收获也就越大。努力工作可能会造成工作与生活失衡，我完全可以理解有的人选择去更好地平衡工作与生活，在工作中不那么拼命，但是拼命工作确实有很多好处，在多数情况下，努力工作会产生叠加效应，越是成功的人就越能成功。\n\n这通常很有趣。生活中最大的乐趣之一就是找到你的目标，并且有所建树，然后你会发现你在这件事上的影响力比你自己本身更重要。一位YC创始人表示：他在离开一家大公司后，尽力发挥了自己的最大影响力，此时他发现自己变得更快乐、更充实。\n\n为发挥出自己最大影响力而努力工作是值得庆祝的。我完全不能理解为什么在美国某些地区努力工作反而成了一件坏事，但我知道世界其他地区肯定不是这样的，那些地区的企业家表现出来的精力和干劲正在快速成为新的社会标杆。\n\n你必须想出一条平衡之策，在努力工作的同时，又不至于透支身体。对此，虽然人们的应对之策不尽相同，但有条几乎不会出错的黄金准则，那就是与相处愉快的人一起从事喜欢的工作。\n\n我认为，那些假装(在你生命中的某个时期)不用把精力放在工作上，就能平步青云的人，其实是在误人子弟。事实上，判断一个人能否笑到最后的关键因素之一就是工作耐力。\n\n另外，我认为刚入职场时就应该要努力工作。努力工作就像利滚利一样，越早开始，获利时间就越长。一般来说，人们身上背负的责任越少，就越容易施展身手。\n\n### 8.大胆一点\n在我看来，与轻松创业相比，人们多半会选择更具挑战性的事业。因为后者往往更激动人心，能带来更大的成就感和满足感。如果你在某个重大问题上取得了进展，就会有源源不断的人前来帮忙。志当存高远，不要害怕去做你真正想做的事情。\n\n如果别人都在创办 meme 公司，而唯独你想创办一家基因编辑公司那就去做吧，不要犹豫。\n\n追随你的好奇心。那些让你感到兴奋的事情，通常也适用于别人。\n\n### 9.足够坚定\n很多人都不知道，只要你足够坚持，世界就会以你的意志为转移。但大多数人甚至都不会去尝试，只单纯认为世界有其自身的运作规律。\n\n人的潜力是巨大的，只要敢想就能做成很多事。但大多数人都会怀疑自我、过早放弃，同时又不够努力，种种原因导致大多数人无法充分发挥自身潜能。\n\n询问自身诉求，你通常不能得偿所愿，而且被拒绝的滋味往往不好受。但若一旦成功，效果就会好得出奇。\n\n那些声称“我将永不言弃，直到梦想成真，不论前方有多少艰难险阻，我也会迎难而上”，并将其付诸行动的人，最后几乎总能获得成功。因为他们坚持了足够久，所以最终迎来了幸运之神的眷顾。\n\n在这方面，爱彼迎 (Airbnb)是我认为的行动标杆。业内流传着许多有关爱彼迎的逸闻趣事，虽然我并不推崇他们的做法(比如透支信用卡、每顿都吃一元店买的麦片、乐此不疲地与强劲的对手进行较量等等) 但是正因为他们足够坚持，最后终于时来运转。\n\n只有保持乐观才能足够坚定，而乐观这种性格特征是可以通过练习逐步提升的，而悲观者是很难成功的。\n\n### 10.保持强劲的市场竞争力\n大多数人都明白，企业竞争力越强，价值就越高。这点至关重要，而且也是显而易见的。这同样也适用于个人。如果你所从事的工作具有可替代性，那么你最终就会被薪资要求更低的人所取代。\n\n增强竞争力的最佳方式就是建立话语权。例如，你可以利用好个人关系，打造强大的个人品牌，或是在不同领域的交叉点建立起自己的个人优势。当然增强竞争力的方式还有很多但不论采取什么方式，关键是你必须要做到这一点。\n\n大多数人会模仿身边人的做法，但这种方式并不可取，如果一味模仿他人，那你还有什么竞争优势可言呢？\n\n### 11.建立人际网络\n出色的工作需要团队合作。打造既可密切合作又可轻松相处的优质人际网络是事业成功的必要因素。拥有优秀人才的人际网络的规模会决定你能成功的上限。\n\n建立人际网络的有效方法之一是尽可能多帮助他人。长期以来，这种行为方式给我带来了最佳职场机遇以及四项最佳投资中的三项。我总是惊讶与发生在自己身上的意外之喜，仅仅因为我十年前曾帮助过一位企业创始人。\n\n建立人际网络的另一个途径是拥有好的名声，不亏待每一个一起共事的人。要大方慷慨地与他人分享资源，这会给你带来10倍、100倍的回报。此外，要知人善用，让每个人都能充分施展自己的才华。\n\n我们既要尽力挖掘他人的潜力但是又不能逼得太紧，这容易让人感到精疲力尽。每个人都有各自擅长的领域，因此，我们要多看看自己的优点，不要总盯着缺点，要用优点来定义自身。面对缺点，我们要承认它，想办法弥补它，不要让缺点成为我们前进路上的阻碍。我常能在一些创业者口中听到这样的说法“我不能做A，因为我不擅长B”。这种思维方式让我十分吃惊。这反映出他们缺乏创造力。弥补弱点的最佳方式是聘请互补的团队成员，而不是雇佣那些跟你擅长相同事情的人。\n\n慧眼识珠挖掘未被发掘的人才是建立人际网络的有效途径。通过练习，我们能快速识别那些优质有动力、有创造力的人才。挖掘人才最简单的方式就是多社交，多与他人打交道并且与那些给你留下深刻印象的人保持联系。要记住一点，不要局限于他人过往的工作经验和当前成就，我们需要发掘那些有潜力且能在短时间激发潜能的人。\n\n每当遇到新人，我都会扪心自问“这个人有异于常人的能力吗？”对于渴求人才的人来说，这个问题很值得思考。\n\n建立人际网络的特例是找到你生命中的贵人，特别是在职业生涯早期。毫无疑问，能做到这点的最佳方法就是主动去帮助他人（记住，你必须在日后回报你的贵人！）\n\n最后，我们要结交那些积极向上且志同道合之人。\n\n### 12.资产决定财富\n小时候，我对经济的最大误解就是人们通过高薪发财致富。虽然也有一些特例，比如说娱乐圈的艺人，但从以往的福布斯榜单来看，几乎没有人是靠高薪荣登榜单的。\n\n拥有能迅速增值的东西才能真正发家致富。这些东西可以是商业资产、不动产、自然资源、知识产权等。但无论怎样，你需要实际拥有一些东西，而不是单靠出卖时间赚取工资，出卖时间赢来的财富只会呈慢速线性增长。\n\n让事物迅速增值的最佳方法就是大量制造人们想要的东西。\n\n### 13.要有内驱力\n大多数人主要都是靠外部驱动，他们做事情是为了让别人佩服。这种做法坏处颇多，但以下两点最为突出：\n\n首先这会导致你人云亦云，因循守旧。在工作中，你会过于在意他人的看法，这种在意程度可能已经远远超出了你的意识，并且这会阻碍你从事趣味性工作，即使你正在做这样的工作，也不过是在炒冷饭。\n\n其次，这会让你误判风险等级。从短期影响来看，你会将注意力主要放在和他人的竞争上，以确保不会在竞争游戏中落后。\n\n聪明人似乎更容易受到这种外驱力的影响。了解到了这一点可以帮助你摆脱这种影响，但帮助不大，我们必须要极其谨慎才能不至于掉入模仿他人的陷阱中。\n\n我认识的大多数成功人士都是靠自我驱动。他们做事情是为了让自己心悦诚服，因为他们觉得给世界带来改变是自己的责任。当你赚得盆满钵满并且拥有了较高的社会地位之后，金钱和名誉对你的吸引力开始逐渐消失，这时候内驱力就成为了唯一的动力，推动你向更高的地方攀登。\n\n这就是驱动力重要性的体现。驱动力是我了解他人时最先考察的点。我们很难用一套规则去定义正确的驱动力，但是当你遇到它时立刻就能有所体会。在这件事上，Jessica Livingston和Paul Graham是我认为的行动标杆。在YC创办的最初几年，人人都不看好它的发展，没有人认为YC能够成功。但是杰西卡和保罗很看好YC的发展，他们认为如果YC能够成功，将会对世界大有裨益，他们希望能够借此帮助到其他人，并且坚信这种新模式比现存的模式好。\n\n最终你会发现成功是在自己看重的领域里做出出色的成绩。向着自己热爱的方向越早出发就能走得越远，没有热爱之事的人是很难取得成就的。\n\n以上就是这篇博客的全文了，感谢也恭喜你看到这里，说明你是一个想要改变自己的人，很喜欢最近听到的一个道理，我总结在最后，与大家共勉！\n> “其实我今天说的这些建议，结论并不重要，因为我相信大家也不会因为今天听我说了一遍，明天你就会去实践，所以最重要的是，你要记得这些事情背后更深层的意义是什么。当你懂的了的事情背后的意义，日积月累，哪天你就可以顿悟，然后你就回去行动，最终带来一些改变 ” -	冴羽','[\"文章\",\"B站\",\"视频\",\"ChatGPT\"]',0,0,1,'2023-03-21 22:41:13','2023-03-21 22:41:13',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1638189024357142530,'什么是数据库事务？讲一下事务的 ACID 特性？【02.20 - 30天面试题挑战】ccc','# 什么是数据库事务？\n\n- 简单来说：事务通常是由一个或一组SQL组成的，组成一个事务的SQL一般都是一个业务操作，例如下单业务：「扣库存数量、增加订单详情记录、插入物流信息」，这一组SQL就可以组成一个事务。\n- 事务是由 MySQL 的引擎来实现的。\n- InnoDB 引擎它是支持事务的，MySQL 原生的 MyISAM 引擎就不支持事务。\n\n# 讲一下事务的 ACID 特性？\n1. **原子性（**A**tomicity）**\n一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样\n    > 买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。\n2. **一致性（**C**onsistency）**\n是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。\n    > 用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。\n3. **独立性/隔离性（**I**solation）**\n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。\n    > 消费者购买商品这个事务，是不影响其他消费者购买的。\n4. **持久性（**D**urability）**\n事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。222','[\"文章\",\"MySQL\",\"面试题挑战记录\"]',0,0,1,'2023-03-21 22:41:13','2023-03-31 00:35:07',0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL),
(1654450364197416962,'大二-java-实习','<p><span style=\"color:#e8e6e3\"><span style=\"font-size:15px\"><span style=\"background-color:#181a1b\">大二专科生，想在这学期结束找到一份实习，麻烦鱼皮给些建议</span></span></span></p>','[\"简历\",\"实习\",\"后端\",\"专科\",\"大二\",\"Java\"]',0,0,1630549686748196866,'2023-05-06 14:57:54','2023-05-06 14:57:54',0,'无名',NULL,NULL,NULL,'0','0',NULL,'true',NULL,0,NULL,1,NULL,NULL,0,NULL,31,NULL),
(1654479553654992898,'初识 Spring Security','### 前言\n\nSpring Security 是什么呢，在官网里时这样描述的\n\n> Spring Security是一个框架，提供 认证（authentication）、授权（authorization） 和 保护，以抵御常见的攻击。它对保护命令式和响应式应用程序有一流的支持，是保护基于Spring的应用程序的事实标准。\n\n简而言之就是一个安全框架，能够很好的保护我们的 Spring 应用\n\n### Spring Security执行流程（简化）\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1626574509983178753/NDLHc9LJ-image.png)\n（图来自B站：三更草堂）\n从图中可以看到，用户输入的用户名密码会被一路传到 DaoAuthenticationProvider（后文简称 DAP ）， 然后由 InMemoryUserDetailsManager （实现了 UserDetailsService 接口）根据用户名从内存中查找到对应的用户信息并返回给 DAP 。 DAP 将查到的信息与用户输入的信息进行比对，如果正确则返回并存储认证对象（没有json返回值）。\n\n### 整合数据库\n\n上面提到，Spring Security 默认是在内存中查找用户信息，这是不符合我们实际开发的场景的。我们需要从数据库中查到真实的用户信息。\n这时候就需要用到 UserDetailsService 接口，因为最后查找用户的操作是由该接口定义的，我们只需要实现该接口并实现 loadUserByUsername 方法，即可实现从数据库中查找用户信息。\n\n```java\n    @Resource\n    private SysUserService sysUserService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = sysUserService.getUserByUserName(username);\n        if (user == null) {\n            throw new RuntimeException(\"账号或密码错误\");\n        }\n        LoginUser loginUser = new LoginUser(user);\n        return loginUser;\n    }\n```\n\nloadUserByUsername 方法要求返回的 UserDeatils 对象是 Spring Security 的内置用户对象，我们可以通过组合的方式将查出的用户封装为 UserDeatils 对象。\n\n```java\npackage com.cowz.databasedemo.entity.security;\n\nimport com.cowz.databasedemo.entity.SysUser;\nimport lombok.AllArgsConstructor;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private SysUser user;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUsername();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n```\n\n其中 SysUser 就是我们系统中的用户对象。\n\n### 密码加密器\n\n做完以上操作在进行测试时，会报一个异常\n\n```java\njava.lang.IllegalArgumentException:There is no PasswordEncoder mapped for the id \"null\"\n```\n\n这是由于没有配置密码加密器所引起的，密码加密器确保我们的密码在数据库中是以密文而不是明文存储的。为此我们需要进行以下的配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n','[\"文章\",\"Spring\",\"后端\",\"安全\"]',0,0,1626574509983178753,'2023-05-06 14:57:21','2023-05-06 14:57:21',0,'松柏',NULL,NULL,NULL,'0','0',NULL,NULL,NULL,0,NULL,1,NULL,NULL,0,NULL,10,NULL),
(1654479920002281473,'整合SpringSecurity自定义登录流程','### 前言\n\n自定义登录流程是整合 SpringSecurity 开发必不可少的一步。[上篇文章](https://juejin.cn/post/7227020874888331324)我们介绍了整合数据库的登录，本篇文章在此基础上整理了 SpringSecurity + JWT + Redis 的登录流程。\n\n### 整体流程图\n\n登录及认证的整体流程如下图：\n\n![1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png](https://pic.code-nav.cn/post_picture/1626574509983178753/uL6iuM5N-1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png)\n\n### 依赖\n\n除了 SpringSecurity 的相关依赖外，还需要 Redis 和 hutool （强大且全面的工具包，本篇文章中 JWT 的相关类也来自该包） 的依赖。\n\n```xml\n<!-- springboot整合的redis依赖，里面集成了 spring-data-redis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.8.13</version>\n</dependency>\n```\n\n### 配置\n\n在整个流程中，我们用到了 SpringSecurity + JWT + Redis ，需要配置的是SpringSecurity 和 Redis。\n\n##### SpringSecurity 配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Resource\n    private JwtFilter jwtFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * 注入 AuthenticationManager 对象，用于调用认证方法\n     *\n     * @return\n     * @throws Exception\n     */\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /**\n     * 放行登录接口\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // 关闭csrf\n                .csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // 把jwt过滤器放到UsernamePasswordAuthenticationFilter前,便于先判断用户是否登录,再决定是否登录\n                .authorizeRequests()\n                // 对于登录接口允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n\n    }\n\n}\n\n```\n\n在配置类中，我们注入了 AuthenticationManager 对象。这个对象在上篇文章我们提到过，用于调用认证方法。但是在父类 WebSecurityConfigurerAdapter 中并没有将它注入到容器中，而我们又需要在自己的登录接口中调用它，因此需要重写 authenticationManagerBean 方法并将返回的对象注入到容器中。\nconfigure(HttpSecurity http) 方法用于配置路由，只开放登录接口，其他接口都需要认证。\n\n##### Redis配置\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        // 设置序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(\n                Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置redisTemplate\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\n        RedisSerializer<?> stringSerializer = new StringRedisSerializer();\n        redisTemplate.setKeySerializer(stringSerializer);// key序列化\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化\n        redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n\n\n```\n\n在 Redis 配置中大部分是常规的序列化配置，特殊的是 ObjectMapper ，这个配置是为因为存储在 Redis 的实体类中除了成员变量的 get 方法外，其他方法不能有返回值，否则会导致反序列化异常，而 ObjectMapper 就是为了解决这个问题。\n反序列化异常的问题可以通过下面的代码验证\n\n```java\n@Test\npublic void test(){\n    RedisTestEntity entity = new RedisTestEntity();\n    entity.setName(\"111\");\n    redisTemplate.opsForValue().set(\"name\", entity);\n}\n\n@Test\npublic void get(){\n    Object name = redisTemplate.opsForValue().get(\"name\");\n    System.out.println(name);\n}\n\n@Data\npublic class RedisTestEntity {\n    private String name;\n\n    public Integer requireAge(){\n        return 18;\n    }\n}\n```\n\n### 定义登录接口\n\n##### 参数的接收\n\n```java\n@Data\npublic class UserLogin {\n    private String username;\n    private String password;\n}\n```\n\n##### controller部分\n\n```java\n@PostMapping(\"/login\")\npublic R<String> login(@RequestBody UserLogin userLogin){\n    String jwt = securityService.login(userLogin);\n    return R.success().data(jwt);\n}\n```\n\ncontroller 只是负责匹配路由和返回数据，业务通过 service 的相关方法完成，因此 controller 中没有太多代码\n\n##### service部分\n\n```java\n@Resource\nprivate AuthenticationManager manager;\n@Resource\nprivate RedisTemplate redisTemplate;\n@Override\npublic String login(UserLogin userLogin) {\n    Authentication userAuthentication = new UsernamePasswordAuthenticationToken(userLogin.getUsername(), userLogin.getPassword());\n    Authentication authenticate = manager.authenticate(userAuthentication);\n    // 如果认证成功则进入生成token的逻辑\n    if (authenticate.isAuthenticated()) {\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        SysUser user = loginUser.getUser();\n        // 将登录成功的对象存入redis\n        redisTemplate.opsForValue().set(KeyUtil.getLoginUserKey(user.getUserId()), loginUser);\n        // 生成token\n        String token = JWT\n                .create()\n                .setPayload(userLoginId, user.getUserId())\n                // (签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n                .setIssuedAt(new Date())\n                // 过期时间七天\n                .setExpiresAt(new Date(System.currentTimeMillis() + DateUnit.WEEK.getMillis()))\n                // // 设置HS256为加密算法，以用户的密码为盐（密钥）\n                .setSigner(\"HMD5\", salt.getBytes(StandardCharsets.UTF_8))\n                .sign();\n\n        return token;\n    }\n    throw new RuntimeException(\"用户名或密码错误\");\n}\n```\n\nservice 完成了登录的主要流程，包括：\n\n1. 调用 AuthenticationManager 实例的 authenticate 方法对用户的账号密码进行验证，该方法会调用到我们上篇文章自定义的方法，通过查询数据库的数据完成校验\n2. 如果校验成功，则将用户信息存入 Redis 并生成相应 token ，同时将用户 id 存入 token 的荷载中，失败则抛出异常\n\n### 登录过滤器\n\n完成登录后，在以后的每次请求都需要在请求头中带上 token 以便于认证，认证操作通过过滤器完成（关于 jwt 的具体知识本篇文章不做探讨，不熟悉请自行查阅相关资料）。\n\n```java\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token = request.getHeader(\"token\");\n        // 没有token，去走登录流程\n        if (StrUtil.isBlank(token)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        // token不能为空\n        JWT jwt = JWTUtil.parseToken(token);\n        // 验证token是否合法\n        HMacJWTSigner singer = new HMacJWTSigner(AlgorithmUtil.getAlgorithm(\"HMD5\"), salt.getBytes(StandardCharsets.UTF_8));\n        boolean common = jwt.verify(singer);\n        // 验证时间，失败会抛出异常\n        try {\n            JWTValidator.of(jwt).validateDate(DateUtil.date());\n        } catch (ValidateException exception) {\n            throw new TokenInvalidException(\"token异常\");\n        }\n        if (common){\n            NumberWithFormat userIdObj = (NumberWithFormat)jwt.getPayload(userLoginId);\n            Integer userId = userIdObj.intValue();\n            LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get(KeyUtil.getLoginUserKey(userId));\n            // 如果用户不存在，说明token异常\n            if (loginUser == null) {\n                throw new TokenInvalidException(\"token异常\");\n            }\n\n            // 将用户信息存入 SecurityContextHolder ，以便本次在请求中使用\n            UsernamePasswordAuthenticationToken authenticationLoginUser = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n            SecurityContextHolder.getContext().setAuthentication(authenticationLoginUser);\n\n            filterChain.doFilter(request, response);\n        }\n\n    }\n}\n```\n\n我们自定义的过滤器类继承了 OncePerRequestFilter 类并重写了 doFilterInternal 方法，然后在 SpringSecurity 的配置类中将其添加到 UsernamePasswordAuthenticationFilter 前面（校验账号密码之前），对应配置类中的如下代码\n\n```java\nhttp.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n在过滤器中，我们首先校验了 token 是否存在。如果不存在则直接放行，然后在后续校验权限时会被自动拦截下来。存在则验证 token 的合法性，通过后从 token 拿到用户 id ，从 Redis 中获取到用户信息，如果不存在说明用户的登录状态异常（可能是退出了登录状态，后文会说）。从 Redis 中取到用户信息后，就可以将用户信息存到 SecurityContextHolder 中，方便后续进行认证、授权以及使用。最后放行，执行后续操作。\n\n### 退出登录\n\n在做完前面的操作后，退出登录的操作就很简单了。\n\n```java\n@PostMapping(\"/logout\")\npublic R<String> logout(){\n    Boolean delete = securityService.logout();\n    return R.success().data(delete);\n}\n```\n\n```java\n@Override\npublic Boolean logout() {\n    LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    Integer userId = loginUser.getUser().getUserId();\n    Boolean delete = redisTemplate.delete(KeyUtil.getLoginUserKey(userId));\n    return delete;\n}\n```\n\ncontroller 和 service 的代码分别如图。\n在 service 中我们删除了 Redis 中的用户信息，这也就解释了为什么过滤器中会存在 token 合法但是用户信息不存在的情况（退出登录），当然也可能有其它的特殊情况。\n\n### 结语\n\n本篇文章就到这了，下一篇应该是关于授权的内容，我们下次再见。','[\"文章\",\"Java\",\"Redis\"]',0,1,1626574509983178753,'2023-05-06 14:57:11','2023-05-06 14:57:11',0,'松柏',NULL,NULL,NULL,'0','0',NULL,NULL,NULL,0,NULL,1,NULL,NULL,0,NULL,19,NULL),
(1654671418366922753,'整合SpringSecurity自定义登录流程','### 前言\n\n自定义登录流程是整合 SpringSecurity 开发必不可少的一步。[上篇文章](https://juejin.cn/post/7227020874888331324)我们介绍了整合数据库的登录，本篇文章在此基础上整理了 SpringSecurity + JWT + Redis 的登录流程。\n\n### 整体流程图\n\n登录及认证的整体流程如下图：\n\n![1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png](https://pic.code-nav.cn/post_picture/1626574509983178753/uL6iuM5N-1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png)\n\n### 依赖\n\n除了 SpringSecurity 的相关依赖外，还需要 Redis 和 hutool （强大且全面的工具包，本篇文章中 JWT 的相关类也来自该包） 的依赖。\n\n```xml\n<!-- springboot整合的redis依赖，里面集成了 spring-data-redis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.8.13</version>\n</dependency>\n```\n\n### 配置\n\n在整个流程中，我们用到了 SpringSecurity + JWT + Redis ，需要配置的是SpringSecurity 和 Redis。\n\n##### SpringSecurity 配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Resource\n    private JwtFilter jwtFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * 注入 AuthenticationManager 对象，用于调用认证方法\n     *\n     * @return\n     * @throws Exception\n     */\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /**\n     * 放行登录接口\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // 关闭csrf\n                .csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // 把jwt过滤器放到UsernamePasswordAuthenticationFilter前,便于先判断用户是否登录,再决定是否登录\n                .authorizeRequests()\n                // 对于登录接口允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n\n    }\n\n}\n\n```\n\n在配置类中，我们注入了 AuthenticationManager 对象。这个对象在上篇文章我们提到过，用于调用认证方法。但是在父类 WebSecurityConfigurerAdapter 中并没有将它注入到容器中，而我们又需要在自己的登录接口中调用它，因此需要重写 authenticationManagerBean 方法并将返回的对象注入到容器中。\nconfigure(HttpSecurity http) 方法用于配置路由，只开放登录接口，其他接口都需要认证。\n\n##### Redis配置\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        // 设置序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(\n                Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置redisTemplate\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\n        RedisSerializer<?> stringSerializer = new StringRedisSerializer();\n        redisTemplate.setKeySerializer(stringSerializer);// key序列化\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化\n        redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n\n\n```\n\n在 Redis 配置中大部分是常规的序列化配置，特殊的是 ObjectMapper ，这个配置是为因为存储在 Redis 的实体类中除了成员变量的 get 方法外，其他方法不能有返回值，否则会导致反序列化异常，而 ObjectMapper 就是为了解决这个问题。\n反序列化异常的问题可以通过下面的代码验证\n\n```java\n@Test\npublic void test(){\n    RedisTestEntity entity = new RedisTestEntity();\n    entity.setName(\"111\");\n    redisTemplate.opsForValue().set(\"name\", entity);\n}\n\n@Test\npublic void get(){\n    Object name = redisTemplate.opsForValue().get(\"name\");\n    System.out.println(name);\n}\n\n@Data\npublic class RedisTestEntity {\n    private String name;\n\n    public Integer requireAge(){\n        return 18;\n    }\n}\n```\n\n### 定义登录接口\n\n##### 参数的接收\n\n```java\n@Data\npublic class UserLogin {\n    private String username;\n    private String password;\n}\n```\n\n##### controller部分\n\n```java\n@PostMapping(\"/login\")\npublic R<String> login(@RequestBody UserLogin userLogin){\n    String jwt = securityService.login(userLogin);\n    return R.success().data(jwt);\n}\n```\n\ncontroller 只是负责匹配路由和返回数据，业务通过 service 的相关方法完成，因此 controller 中没有太多代码\n\n##### service部分\n\n```java\n@Resource\nprivate AuthenticationManager manager;\n@Resource\nprivate RedisTemplate redisTemplate;\n@Override\npublic String login(UserLogin userLogin) {\n    Authentication userAuthentication = new UsernamePasswordAuthenticationToken(userLogin.getUsername(), userLogin.getPassword());\n    Authentication authenticate = manager.authenticate(userAuthentication);\n    // 如果认证成功则进入生成token的逻辑\n    if (authenticate.isAuthenticated()) {\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        SysUser user = loginUser.getUser();\n        // 将登录成功的对象存入redis\n        redisTemplate.opsForValue().set(KeyUtil.getLoginUserKey(user.getUserId()), loginUser);\n        // 生成token\n        String token = JWT\n                .create()\n                .setPayload(userLoginId, user.getUserId())\n                // (签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n                .setIssuedAt(new Date())\n                // 过期时间七天\n                .setExpiresAt(new Date(System.currentTimeMillis() + DateUnit.WEEK.getMillis()))\n                // // 设置HS256为加密算法，以用户的密码为盐（密钥）\n                .setSigner(\"HMD5\", salt.getBytes(StandardCharsets.UTF_8))\n                .sign();\n\n        return token;\n    }\n    throw new RuntimeException(\"用户名或密码错误\");\n}\n```\n\nservice 完成了登录的主要流程，包括：\n\n1. 调用 AuthenticationManager 实例的 authenticate 方法对用户的账号密码进行验证，该方法会调用到我们上篇文章自定义的方法，通过查询数据库的数据完成校验\n2. 如果校验成功，则将用户信息存入 Redis 并生成相应 token ，同时将用户 id 存入 token 的荷载中，失败则抛出异常\n\n### 登录过滤器\n\n完成登录后，在以后的每次请求都需要在请求头中带上 token 以便于认证，认证操作通过过滤器完成（关于 jwt 的具体知识本篇文章不做探讨，不熟悉请自行查阅相关资料）。\n\n```java\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token = request.getHeader(\"token\");\n        // 没有token，去走登录流程\n        if (StrUtil.isBlank(token)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        // token不能为空\n        JWT jwt = JWTUtil.parseToken(token);\n        // 验证token是否合法\n        HMacJWTSigner singer = new HMacJWTSigner(AlgorithmUtil.getAlgorithm(\"HMD5\"), salt.getBytes(StandardCharsets.UTF_8));\n        boolean common = jwt.verify(singer);\n        // 验证时间，失败会抛出异常\n        try {\n            JWTValidator.of(jwt).validateDate(DateUtil.date());\n        } catch (ValidateException exception) {\n            throw new TokenInvalidException(\"token异常\");\n        }\n        if (common){\n            NumberWithFormat userIdObj = (NumberWithFormat)jwt.getPayload(userLoginId);\n            Integer userId = userIdObj.intValue();\n            LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get(KeyUtil.getLoginUserKey(userId));\n            // 如果用户不存在，说明token异常\n            if (loginUser == null) {\n                throw new TokenInvalidException(\"token异常\");\n            }\n\n            // 将用户信息存入 SecurityContextHolder ，以便本次在请求中使用\n            UsernamePasswordAuthenticationToken authenticationLoginUser = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n            SecurityContextHolder.getContext().setAuthentication(authenticationLoginUser);\n\n            filterChain.doFilter(request, response);\n        }\n\n    }\n}\n```\n\n我们自定义的过滤器类继承了 OncePerRequestFilter 类并重写了 doFilterInternal 方法，然后在 SpringSecurity 的配置类中将其添加到 UsernamePasswordAuthenticationFilter 前面（校验账号密码之前），对应配置类中的如下代码\n\n```java\nhttp.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n在过滤器中，我们首先校验了 token 是否存在。如果不存在则直接放行，然后在后续校验权限时会被自动拦截下来。存在则验证 token 的合法性，通过后从 token 拿到用户 id ，从 Redis 中获取到用户信息，如果不存在说明用户的登录状态异常（可能是退出了登录状态，后文会说）。从 Redis 中取到用户信息后，就可以将用户信息存到 SecurityContextHolder 中，方便后续进行认证、授权以及使用。最后放行，执行后续操作。\n\n### 退出登录\n\n在做完前面的操作后，退出登录的操作就很简单了。\n\n```java\n@PostMapping(\"/logout\")\npublic R<String> logout(){\n    Boolean delete = securityService.logout();\n    return R.success().data(delete);\n}\n```\n\n```java\n@Override\npublic Boolean logout() {\n    LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    Integer userId = loginUser.getUser().getUserId();\n    Boolean delete = redisTemplate.delete(KeyUtil.getLoginUserKey(userId));\n    return delete;\n}\n```\n\ncontroller 和 service 的代码分别如图。\n在 service 中我们删除了 Redis 中的用户信息，这也就解释了为什么过滤器中会存在 token 合法但是用户信息不存在的情况（退出登录），当然也可能有其它的特殊情况。\n\n### 结语\n\n本篇文章就到这了，下一篇应该是关于授权的内容，我们下次再见。','[\"文章\",\"Java\",\"Redis\"]',0,1,1626574509983178753,'2023-05-06 10:16:04','2023-05-06 10:16:04',0,'松柏',NULL,NULL,NULL,'0','0',NULL,NULL,NULL,0,NULL,1,NULL,NULL,0,NULL,13,NULL),
(1654671433718075394,'初识 Spring Security','### 前言\n\nSpring Security 是什么呢，在官网里时这样描述的\n\n> Spring Security是一个框架，提供 认证（authentication）、授权（authorization） 和 保护，以抵御常见的攻击。它对保护命令式和响应式应用程序有一流的支持，是保护基于Spring的应用程序的事实标准。\n\n简而言之就是一个安全框架，能够很好的保护我们的 Spring 应用\n\n### Spring Security执行流程（简化）\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1626574509983178753/NDLHc9LJ-image.png)\n（图来自B站：三更草堂）\n从图中可以看到，用户输入的用户名密码会被一路传到 DaoAuthenticationProvider（后文简称 DAP ）， 然后由 InMemoryUserDetailsManager （实现了 UserDetailsService 接口）根据用户名从内存中查找到对应的用户信息并返回给 DAP 。 DAP 将查到的信息与用户输入的信息进行比对，如果正确则返回并存储认证对象（没有json返回值）。\n\n### 整合数据库\n\n上面提到，Spring Security 默认是在内存中查找用户信息，这是不符合我们实际开发的场景的。我们需要从数据库中查到真实的用户信息。\n这时候就需要用到 UserDetailsService 接口，因为最后查找用户的操作是由该接口定义的，我们只需要实现该接口并实现 loadUserByUsername 方法，即可实现从数据库中查找用户信息。\n\n```java\n    @Resource\n    private SysUserService sysUserService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = sysUserService.getUserByUserName(username);\n        if (user == null) {\n            throw new RuntimeException(\"账号或密码错误\");\n        }\n        LoginUser loginUser = new LoginUser(user);\n        return loginUser;\n    }\n```\n\nloadUserByUsername 方法要求返回的 UserDeatils 对象是 Spring Security 的内置用户对象，我们可以通过组合的方式将查出的用户封装为 UserDeatils 对象。\n\n```java\npackage com.cowz.databasedemo.entity.security;\n\nimport com.cowz.databasedemo.entity.SysUser;\nimport lombok.AllArgsConstructor;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private SysUser user;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUsername();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n```\n\n其中 SysUser 就是我们系统中的用户对象。\n\n### 密码加密器\n\n做完以上操作在进行测试时，会报一个异常\n\n```java\njava.lang.IllegalArgumentException:There is no PasswordEncoder mapped for the id \"null\"\n```\n\n这是由于没有配置密码加密器所引起的，密码加密器确保我们的密码在数据库中是以密文而不是明文存储的。为此我们需要进行以下的配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n','[\"文章\",\"Spring\",\"后端\",\"安全\"]',0,0,1626574509983178753,'2023-05-06 10:16:24','2023-05-06 10:16:24',0,'松柏',NULL,NULL,NULL,'0','0',NULL,NULL,NULL,0,NULL,1,NULL,NULL,0,NULL,5,NULL),
(1654671700270288898,'大二-java-实习','<p><span style=\"color:#e8e6e3\"><span style=\"font-size:15px\"><span style=\"background-color:#181a1b\">大二专科生，想在这学期结束找到一份实习，麻烦鱼皮给些建议</span></span></span></p>','[\"简历\",\"实习\",\"后端\",\"专科\",\"大二\",\"Java\"]',0,0,1630549686748196866,'2023-05-06 10:16:29','2023-05-06 10:16:29',0,'无名',NULL,NULL,NULL,'0','0',NULL,'true',NULL,0,NULL,1,NULL,NULL,0,NULL,22,NULL),
(1654675249574219777,'大三 前端 实习简历','<p>鱼皮大佬，麻烦帮我看看简历</p><p>1.我想知道自己需不需要添加别的类型的项目，投了好多简历但没有后续，总觉得是不是自己的简历不太好，但改来改去又没有很大的变化</p><p>2.需不需要再多学一些技术，我看到有一些岗位要求有微信小程序之类的</p>','[\"简历\"]',0,0,1629002512990240769,'2023-05-06 14:56:20','2023-05-06 14:56:20',0,'呐',NULL,NULL,NULL,'0','0',NULL,'true','[\"https://pic.code-nav.cn/post_picture/1601072287388278786/pIFBJlQA-vip_image_placeholder.png\"]',0,NULL,1,NULL,NULL,0,NULL,7,NULL),
(1654747134613905410,'大三 前端 实习简历','<p>鱼皮大佬，麻烦帮我看看简历</p><p>1.我想知道自己需不需要添加别的类型的项目，投了好多简历但没有后续，总觉得是不是自己的简历不太好，但改来改去又没有很大的变化</p><p>2.需不需要再多学一些技术，我看到有一些岗位要求有微信小程序之类的</p>','[\"简历\"]',0,0,1629002512990240769,'2023-05-06 15:17:09','2023-05-06 15:17:09',0,'呐',NULL,NULL,NULL,'0','0',NULL,'true','[\"https://pic.code-nav.cn/post_picture/1601072287388278786/pIFBJlQA-vip_image_placeholder.png\"]',0,NULL,1,NULL,NULL,0,NULL,8,1654675249574219777),
(1654747246559879170,'整合SpringSecurity自定义登录流程','### 前言\n\n自定义登录流程是整合 SpringSecurity 开发必不可少的一步。[上篇文章](https://juejin.cn/post/7227020874888331324)我们介绍了整合数据库的登录，本篇文章在此基础上整理了 SpringSecurity + JWT + Redis 的登录流程。\n\n### 整体流程图\n\n登录及认证的整体流程如下图：\n\n![1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png](https://pic.code-nav.cn/post_picture/1626574509983178753/uL6iuM5N-1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png)\n\n### 依赖\n\n除了 SpringSecurity 的相关依赖外，还需要 Redis 和 hutool （强大且全面的工具包，本篇文章中 JWT 的相关类也来自该包） 的依赖。\n\n```xml\n<!-- springboot整合的redis依赖，里面集成了 spring-data-redis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.8.13</version>\n</dependency>\n```\n\n### 配置\n\n在整个流程中，我们用到了 SpringSecurity + JWT + Redis ，需要配置的是SpringSecurity 和 Redis。\n\n##### SpringSecurity 配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Resource\n    private JwtFilter jwtFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * 注入 AuthenticationManager 对象，用于调用认证方法\n     *\n     * @return\n     * @throws Exception\n     */\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /**\n     * 放行登录接口\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // 关闭csrf\n                .csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // 把jwt过滤器放到UsernamePasswordAuthenticationFilter前,便于先判断用户是否登录,再决定是否登录\n                .authorizeRequests()\n                // 对于登录接口允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n\n    }\n\n}\n\n```\n\n在配置类中，我们注入了 AuthenticationManager 对象。这个对象在上篇文章我们提到过，用于调用认证方法。但是在父类 WebSecurityConfigurerAdapter 中并没有将它注入到容器中，而我们又需要在自己的登录接口中调用它，因此需要重写 authenticationManagerBean 方法并将返回的对象注入到容器中。\nconfigure(HttpSecurity http) 方法用于配置路由，只开放登录接口，其他接口都需要认证。\n\n##### Redis配置\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        // 设置序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(\n                Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置redisTemplate\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\n        RedisSerializer<?> stringSerializer = new StringRedisSerializer();\n        redisTemplate.setKeySerializer(stringSerializer);// key序列化\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化\n        redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n\n\n```\n\n在 Redis 配置中大部分是常规的序列化配置，特殊的是 ObjectMapper ，这个配置是为因为存储在 Redis 的实体类中除了成员变量的 get 方法外，其他方法不能有返回值，否则会导致反序列化异常，而 ObjectMapper 就是为了解决这个问题。\n反序列化异常的问题可以通过下面的代码验证\n\n```java\n@Test\npublic void test(){\n    RedisTestEntity entity = new RedisTestEntity();\n    entity.setName(\"111\");\n    redisTemplate.opsForValue().set(\"name\", entity);\n}\n\n@Test\npublic void get(){\n    Object name = redisTemplate.opsForValue().get(\"name\");\n    System.out.println(name);\n}\n\n@Data\npublic class RedisTestEntity {\n    private String name;\n\n    public Integer requireAge(){\n        return 18;\n    }\n}\n```\n\n### 定义登录接口\n\n##### 参数的接收\n\n```java\n@Data\npublic class UserLogin {\n    private String username;\n    private String password;\n}\n```\n\n##### controller部分\n\n```java\n@PostMapping(\"/login\")\npublic R<String> login(@RequestBody UserLogin userLogin){\n    String jwt = securityService.login(userLogin);\n    return R.success().data(jwt);\n}\n```\n\ncontroller 只是负责匹配路由和返回数据，业务通过 service 的相关方法完成，因此 controller 中没有太多代码\n\n##### service部分\n\n```java\n@Resource\nprivate AuthenticationManager manager;\n@Resource\nprivate RedisTemplate redisTemplate;\n@Override\npublic String login(UserLogin userLogin) {\n    Authentication userAuthentication = new UsernamePasswordAuthenticationToken(userLogin.getUsername(), userLogin.getPassword());\n    Authentication authenticate = manager.authenticate(userAuthentication);\n    // 如果认证成功则进入生成token的逻辑\n    if (authenticate.isAuthenticated()) {\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        SysUser user = loginUser.getUser();\n        // 将登录成功的对象存入redis\n        redisTemplate.opsForValue().set(KeyUtil.getLoginUserKey(user.getUserId()), loginUser);\n        // 生成token\n        String token = JWT\n                .create()\n                .setPayload(userLoginId, user.getUserId())\n                // (签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n                .setIssuedAt(new Date())\n                // 过期时间七天\n                .setExpiresAt(new Date(System.currentTimeMillis() + DateUnit.WEEK.getMillis()))\n                // // 设置HS256为加密算法，以用户的密码为盐（密钥）\n                .setSigner(\"HMD5\", salt.getBytes(StandardCharsets.UTF_8))\n                .sign();\n\n        return token;\n    }\n    throw new RuntimeException(\"用户名或密码错误\");\n}\n```\n\nservice 完成了登录的主要流程，包括：\n\n1. 调用 AuthenticationManager 实例的 authenticate 方法对用户的账号密码进行验证，该方法会调用到我们上篇文章自定义的方法，通过查询数据库的数据完成校验\n2. 如果校验成功，则将用户信息存入 Redis 并生成相应 token ，同时将用户 id 存入 token 的荷载中，失败则抛出异常\n\n### 登录过滤器\n\n完成登录后，在以后的每次请求都需要在请求头中带上 token 以便于认证，认证操作通过过滤器完成（关于 jwt 的具体知识本篇文章不做探讨，不熟悉请自行查阅相关资料）。\n\n```java\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token = request.getHeader(\"token\");\n        // 没有token，去走登录流程\n        if (StrUtil.isBlank(token)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        // token不能为空\n        JWT jwt = JWTUtil.parseToken(token);\n        // 验证token是否合法\n        HMacJWTSigner singer = new HMacJWTSigner(AlgorithmUtil.getAlgorithm(\"HMD5\"), salt.getBytes(StandardCharsets.UTF_8));\n        boolean common = jwt.verify(singer);\n        // 验证时间，失败会抛出异常\n        try {\n            JWTValidator.of(jwt).validateDate(DateUtil.date());\n        } catch (ValidateException exception) {\n            throw new TokenInvalidException(\"token异常\");\n        }\n        if (common){\n            NumberWithFormat userIdObj = (NumberWithFormat)jwt.getPayload(userLoginId);\n            Integer userId = userIdObj.intValue();\n            LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get(KeyUtil.getLoginUserKey(userId));\n            // 如果用户不存在，说明token异常\n            if (loginUser == null) {\n                throw new TokenInvalidException(\"token异常\");\n            }\n\n            // 将用户信息存入 SecurityContextHolder ，以便本次在请求中使用\n            UsernamePasswordAuthenticationToken authenticationLoginUser = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n            SecurityContextHolder.getContext().setAuthentication(authenticationLoginUser);\n\n            filterChain.doFilter(request, response);\n        }\n\n    }\n}\n```\n\n我们自定义的过滤器类继承了 OncePerRequestFilter 类并重写了 doFilterInternal 方法，然后在 SpringSecurity 的配置类中将其添加到 UsernamePasswordAuthenticationFilter 前面（校验账号密码之前），对应配置类中的如下代码\n\n```java\nhttp.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n在过滤器中，我们首先校验了 token 是否存在。如果不存在则直接放行，然后在后续校验权限时会被自动拦截下来。存在则验证 token 的合法性，通过后从 token 拿到用户 id ，从 Redis 中获取到用户信息，如果不存在说明用户的登录状态异常（可能是退出了登录状态，后文会说）。从 Redis 中取到用户信息后，就可以将用户信息存到 SecurityContextHolder 中，方便后续进行认证、授权以及使用。最后放行，执行后续操作。\n\n### 退出登录\n\n在做完前面的操作后，退出登录的操作就很简单了。\n\n```java\n@PostMapping(\"/logout\")\npublic R<String> logout(){\n    Boolean delete = securityService.logout();\n    return R.success().data(delete);\n}\n```\n\n```java\n@Override\npublic Boolean logout() {\n    LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    Integer userId = loginUser.getUser().getUserId();\n    Boolean delete = redisTemplate.delete(KeyUtil.getLoginUserKey(userId));\n    return delete;\n}\n```\n\ncontroller 和 service 的代码分别如图。\n在 service 中我们删除了 Redis 中的用户信息，这也就解释了为什么过滤器中会存在 token 合法但是用户信息不存在的情况（退出登录），当然也可能有其它的特殊情况。\n\n### 结语\n\n本篇文章就到这了，下一篇应该是关于授权的内容，我们下次再见。','[\"文章\",\"Java\",\"Redis\"]',0,1,1626574509983178753,'2023-05-06 15:17:42','2023-05-06 15:17:42',0,'松柏',NULL,NULL,NULL,'0','0',NULL,NULL,NULL,0,NULL,1,NULL,NULL,0,NULL,19,1654479920002281473),
(1654747247658786817,'初识 Spring Security','### 前言\n\nSpring Security 是什么呢，在官网里时这样描述的\n\n> Spring Security是一个框架，提供 认证（authentication）、授权（authorization） 和 保护，以抵御常见的攻击。它对保护命令式和响应式应用程序有一流的支持，是保护基于Spring的应用程序的事实标准。\n\n简而言之就是一个安全框架，能够很好的保护我们的 Spring 应用\n\n### Spring Security执行流程（简化）\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1626574509983178753/NDLHc9LJ-image.png)\n（图来自B站：三更草堂）\n从图中可以看到，用户输入的用户名密码会被一路传到 DaoAuthenticationProvider（后文简称 DAP ）， 然后由 InMemoryUserDetailsManager （实现了 UserDetailsService 接口）根据用户名从内存中查找到对应的用户信息并返回给 DAP 。 DAP 将查到的信息与用户输入的信息进行比对，如果正确则返回并存储认证对象（没有json返回值）。\n\n### 整合数据库\n\n上面提到，Spring Security 默认是在内存中查找用户信息，这是不符合我们实际开发的场景的。我们需要从数据库中查到真实的用户信息。\n这时候就需要用到 UserDetailsService 接口，因为最后查找用户的操作是由该接口定义的，我们只需要实现该接口并实现 loadUserByUsername 方法，即可实现从数据库中查找用户信息。\n\n```java\n    @Resource\n    private SysUserService sysUserService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = sysUserService.getUserByUserName(username);\n        if (user == null) {\n            throw new RuntimeException(\"账号或密码错误\");\n        }\n        LoginUser loginUser = new LoginUser(user);\n        return loginUser;\n    }\n```\n\nloadUserByUsername 方法要求返回的 UserDeatils 对象是 Spring Security 的内置用户对象，我们可以通过组合的方式将查出的用户封装为 UserDeatils 对象。\n\n```java\npackage com.cowz.databasedemo.entity.security;\n\nimport com.cowz.databasedemo.entity.SysUser;\nimport lombok.AllArgsConstructor;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private SysUser user;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUsername();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n```\n\n其中 SysUser 就是我们系统中的用户对象。\n\n### 密码加密器\n\n做完以上操作在进行测试时，会报一个异常\n\n```java\njava.lang.IllegalArgumentException:There is no PasswordEncoder mapped for the id \"null\"\n```\n\n这是由于没有配置密码加密器所引起的，密码加密器确保我们的密码在数据库中是以密文而不是明文存储的。为此我们需要进行以下的配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n','[\"文章\",\"Spring\",\"后端\",\"安全\"]',0,0,1626574509983178753,'2023-05-06 15:17:42','2023-05-06 15:17:42',0,'松柏',NULL,NULL,NULL,'0','0',NULL,NULL,NULL,0,NULL,1,NULL,NULL,0,NULL,10,1654479553654992898);

/*Table structure for table `post_favour` */

DROP TABLE IF EXISTS `post_favour`;

CREATE TABLE `post_favour` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `postId` bigint NOT NULL COMMENT '帖子 id',
  `userId` bigint NOT NULL COMMENT '创建用户 id',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_postId` (`postId`),
  KEY `idx_userId` (`userId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='帖子收藏';

/*Data for the table `post_favour` */

/*Table structure for table `post_label` */

DROP TABLE IF EXISTS `post_label`;

CREATE TABLE `post_label` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `postId` bigint NOT NULL COMMENT '文章id',
  `labelId` bigint NOT NULL COMMENT '标签id',
  `createTime` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updateTime` timestamp NULL DEFAULT NULL COMMENT '修改时间',
  `isDelete` tinyint DEFAULT NULL COMMENT '逻辑删除标志',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `post_label` */

insert  into `post_label`(`id`,`postId`,`labelId`,`createTime`,`updateTime`,`isDelete`) values 
(1,1654675249574219777,125,NULL,NULL,NULL);

/*Table structure for table `post_thumb` */

DROP TABLE IF EXISTS `post_thumb`;

CREATE TABLE `post_thumb` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `postId` bigint NOT NULL COMMENT '帖子 id',
  `userId` bigint NOT NULL COMMENT '创建用户 id',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_postId` (`postId`),
  KEY `idx_userId` (`userId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='帖子点赞';

/*Data for the table `post_thumb` */

/*Table structure for table `test` */

DROP TABLE IF EXISTS `test`;

CREATE TABLE `test` (
  `province` varchar(128) NOT NULL,
  `order` varchar(128) NOT NULL,
  `time` timestamp NOT NULL,
  `id` bigint NOT NULL AUTO_INCREMENT,
  `sales` double DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `test` */

insert  into `test`(`province`,`order`,`time`,`id`,`sales`) values 
('北京','华北','2017-02-01 00:00:00',1,2800000),
('天津','华北','2017-02-01 00:00:00',2,2800000),
('上海','华东','2018-01-01 00:00:00',3,2900000),
('浙江','华东','2017-12-01 00:00:00',4,4500000),
('天津','华北','2017-12-01 00:00:00',5,2800000),
('江苏','华东','2017-01-03 00:00:00',6,3900000),
('dididi','华北','2018-01-05 00:00:00',7,1900000);

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `userAccount` varchar(256) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '账号',
  `userPassword` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '密码',
  `unionId` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '微信开放平台id',
  `mpOpenId` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '公众号openId',
  `userName` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户昵称',
  `userAvatar` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户头像',
  `userProfile` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户简介',
  `userRole` varchar(256) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'user' COMMENT '用户角色：user/admin/ban',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `isDelete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`),
  KEY `idx_unionId` (`unionId`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户';

/*Data for the table `user` */

insert  into `user`(`id`,`userAccount`,`userPassword`,`unionId`,`mpOpenId`,`userName`,`userAvatar`,`userProfile`,`userRole`,`createTime`,`updateTime`,`isDelete`) values 
(1,'12451235','123456',NULL,NULL,'dididi',NULL,NULL,'user','2023-03-30 17:02:44','2023-03-30 17:02:44',0);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
